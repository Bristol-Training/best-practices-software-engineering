[
  {
    "objectID": "pages/050-licensing.html",
    "href": "pages/050-licensing.html",
    "title": "Licensing your code",
    "section": "",
    "text": "Ever since the Berne Convention of 1886, copyright is immediately bestowed upon a work the moment it is created, without requiring any registration. This means that any copyrightable work that you create is always completely under your control as far as copyright allows. There are good reasons for this but the result is that if you want to share some code you’ve written with someone then they can’t do much useful with it (such as include it in their product) unless you give them an explicit licence to relax the conditions imposed by copyright.\nSince the 1980’s there has been a movement of people who think that all software should be freely sharable and usable by anyone, for any purpose. It is this movement that gave rise to projects such as Linux, Python, Firefox, Wikipedia and VLC. These types of software are referred to as Free Software or Open Source Software. Software is considered Free Software if the software’s users have the following four freedoms philosophy:\n\nThe freedom to run the program as you wish, for any purpose (freedom 0).\nThe freedom to study how the program works, and change it so it does your computing as you wish (freedom 1). Access to the source code is a precondition for this.\nThe freedom to redistribute copies so you can help others (freedom 2).\nThe freedom to distribute copies of your modified versions to others (freedom 3). By doing this you can give the whole community a chance to benefit from your changes. Access to the source code is a precondition for this.\n\nFree Software works within copyright law by providing licences which allow use of the software for any purpose while protecting the author as much as possible. All of the projects mentioned above have a Free Software licence which is what guarantees that they will always remain free, both in terms of cost and what you are allowed to do with them. This contrasts with “closed-source” software such as Microsoft Word which you cannot see the source code for and are not free to share with others and Google Chrome which, while cost-free, is restricted in what you can use it for.\nAs a researcher funded by public money, I feel it is my moral duty to make any outputs from my work freely available for anyone to make use of. This allows others to build upon what I’ve done, furthering science and it also gives me a route to credit by demonstrating the impact of my work on others.\n\nWhen to make your code open\nJust because you would like to make your source code open, does not mean that you are automatically able to do so. For starters you need the explicit permission of every co-author and copyright holder. In the case of an industrial collaboration they might not want the code to be made public and if they are funding the research they may have put constraints on it. In this case, talk to your collaborators and find out what is possible.\nThe other situation that arises in research software is the fear that if the code is made public then either their work will be “stolen” by another University or that someone will find an embarrassing bug in it. A potential solution to the former is to hold off the opening of the software until the paper is submitted/published but realistically it’s simply not a problem that really happens. For the second point, it would be much more embarassing to have a paper submitted and then have to retract it when you find a bug yourself later. By opening your code earlier and allowing more contributions you increase the quality of the code and reduce the chance of a bug slipping through.\n\n\nHow to make your code free and open\nThe steps to making your code open are:\n\nChoose a licence, agreed by everyone on the project\nPut the licence text in a file alongside your code\nPublish your code somewhere such as GitHub or GitLab.\n\n\nChoose a licence\nThere are lots of possible ways to license your code to make it open source, each of which have their own pros and cons. The technicalities of exactly which licence works for you are tricky but to simplify things, you can use a website like choosealicense.com.\nThe choice generally comes down to how permissive you want to be. Either you put almost no constraints on what the user of your code can do with it (e.g. the MIT licence) or you can require that for example, any changes they make to your code must be made public and open source or even that any software which uses your code must be made available wholly as open source too (e.g. the GNU GPL).\n\n\nApply the licence\nMost licences only require that there is a single file in your source code directory called something like LICENSE or LICENSE.txt which contains the text of the licence. Some licences advise that you should also put a message at the top of every file but choosealicense.com will inform you of the appropriate approach.\n\n\nPublish\nYou don’t need to put your code on a public platform but it’s a really valuable thing to do to allow people to discover it and contribute back changes. When you do upload it to somewhere like GitHub, make sure you also include your LICENSE file. For example, the pytest GitHub page includes their LICENSE file and this automatically creates a link in the top-right labelled “⚖️ MIT”:\n\n\n\npytest license link\n\n\nwhich if you click it takes you to the license page which has a header that contain the details of the licence:\n\n\n\npytest license details\n\n\n\n\n\nUniversity of Bristol advice\nIf you are at the University of Bristol then Research & Enterprise Development (RED) provide some advice on licensing software along with plenty of good links to other resources. If you have any questions about open-sourcing software you have developed while working at the University then be sure to read that and contact RED. Also, talk to your Research Software Engineering team as they can likely advise on appropriate approaches.",
    "crumbs": [
      "Licensing your code"
    ]
  },
  {
    "objectID": "pages/99 Summary.html",
    "href": "pages/99 Summary.html",
    "title": "Best Practices in Software Engineering",
    "section": "",
    "text": "Well done for getting this far!\nIn this course we’ve covered some important elements of professional software development:\n\nDocumentation\n\nWhat should be documented\nHow to make your documentation accessible as HTML\n\nLicensing\nTesting\n\nHow to test your code\nWhy to test your code\nParametrising your tests\nChecking for expected errors\nProviding test data in fixtures\n\n\nI consider these three topics to be essential for effective software development along with version control through a tool such as Git.\nYou don’t need to have tested very single corner of your code and you don’t need to have perfect docstrings for your functions but just having something is better than having nothing. These techniques are not about being perfect but simply about being better.\nThings to read up on or attend courses about next would likely be:\n\nVersion control using Git\n\nincluding collaborative development with a platform like GitHub or GitLab using Pull Requests\n\nAutomated testing, also referred to as continuous integration or continuous testing\nCode quality checks (such as pycodestyle, Pylint and MyPy in Python)\nPackaging your software for easy distribution (e.g. using PyPI for Python)\n\nFor information on some of these topics, a good source is The Hitchhiker’s Guide to Python, particularly the section on Writing Great Python Code.\n\n\nThis course was written by Matt Williams. All text is published under a Creative Commons Attribution 4.0 International License with all code snippets licensed as MIT.\nThe source for the material can be found on GitLab where fixes are welcome."
  },
  {
    "objectID": "pages/99 Summary.html#summary",
    "href": "pages/99 Summary.html#summary",
    "title": "Best Practices in Software Engineering",
    "section": "",
    "text": "Well done for getting this far!\nIn this course we’ve covered some important elements of professional software development:\n\nDocumentation\n\nWhat should be documented\nHow to make your documentation accessible as HTML\n\nLicensing\nTesting\n\nHow to test your code\nWhy to test your code\nParametrising your tests\nChecking for expected errors\nProviding test data in fixtures\n\n\nI consider these three topics to be essential for effective software development along with version control through a tool such as Git.\nYou don’t need to have tested very single corner of your code and you don’t need to have perfect docstrings for your functions but just having something is better than having nothing. These techniques are not about being perfect but simply about being better.\nThings to read up on or attend courses about next would likely be:\n\nVersion control using Git\n\nincluding collaborative development with a platform like GitHub or GitLab using Pull Requests\n\nAutomated testing, also referred to as continuous integration or continuous testing\nCode quality checks (such as pycodestyle, Pylint and MyPy in Python)\nPackaging your software for easy distribution (e.g. using PyPI for Python)\n\nFor information on some of these topics, a good source is The Hitchhiker’s Guide to Python, particularly the section on Writing Great Python Code.\n\n\nThis course was written by Matt Williams. All text is published under a Creative Commons Attribution 4.0 International License with all code snippets licensed as MIT.\nThe source for the material can be found on GitLab where fixes are welcome."
  },
  {
    "objectID": "pages/030-testing.html",
    "href": "pages/030-testing.html",
    "title": "Testing",
    "section": "",
    "text": "Testing is extremely important. Without testing, you cannot be sure that your code is doing what you think. Testing is an integral part of software development, and where possible should be done while you are writing code, not after the code has been written.\nNo doubt so far, you have been manually checking that your code does the right thing. Perhaps you are running your code over a particular input file and making sure that you get a correct-looking plot out at the end? Or maybe running it with a few known inputs and checking that you got what you got last time? This is a start but how can you be sure that there’s not a subtle bug that means that the output is incorrect? And if there is a problem, how will you be able to work out exactly which line of code it causing it?\nIn order to be confident that our code it giving a correct output, a test suite is useful which provides a set of known inputs and checks that the code matches a set of known, expected outputs. To make it easier to locate where a bug is occuring, it’s a good idea to make each individual test run over as small an amount of code as possible so that if that test fails, you know where to look for the problem. In Python this “small unit of code” is usually a function.\nLet’s get started by making sure that our add_arrays function matches the outputs we expect. As a reminder, this is what the file arrays.py looks like:\n\"\"\"\nThis module contains functions for manipulating and combining Python lists.\n\"\"\"\n\ndef add_arrays(x, y):\n    \"\"\"\n    This function adds together each element of the two passed lists.\n\n    Args:\n        x (list): The first list to add\n        y (list): The second list to add\n\n    Returns:\n        list: the pairwise sums of ``x`` and ``y``.\n\n    Examples:\n        &gt;&gt;&gt; add_arrays([1, 4, 5], [4, 3, 5])\n        [5, 7, 10]\n    \"\"\"\n    z = []\n    for x_, y_ in zip(x, y):\n        z.append(x_ + y_)\n\n    return z\nSince the name of the module we want to test is arrays, let’s make a file called test_arrays.py which contains the following:\nfrom arrays import add_arrays\n\ndef test_add_arrays():\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n    expect = [5, 7, 9]\n    \n    output = add_arrays(a, b)\n    \n    if output == expect:\n        print(\"OK\")\n    else:\n        print(\"BROKEN\")\n\ntest_add_arrays()\nThis script defines a function called test_add_arrays which defines some known inputs (a and b) and a known, matching output (expect). It passes them to the function add_arrays and compares the output to expected. It will either print OK or BROKEN depending on whether it’s working or not. Finally, we explicitly call the test function.\nWhen we run the script in the Terminal, we see it output OK:\n\n\nTerminal/Command Prompt\n\npython test_arrays.py\n\nOK\n\n\n\n\n\n\nExercise\n\n\n\nBreak the test by changing either a, b or expected and rerun the test script. Make sure that it prints BROKEN in this case. Change it back to a working state once you’ve done this.\n\n\n\nAsserting\nThe method used here works and runs the code correctly but it doesn’t give very useful output. If we had five test functions in our file and three of them were failing we’d see something like:\nOK\nBROKEN\nOK\nBROKEN\nBROKEN\nWe’d then have to cross-check back to our code to see which tests the BROKENs referred to.\nTo be able to automatically relate the output of the failing test to the place where your test failed, you can use an assert statement.\nAn assert statement is followed by something which is either truthy or falsy. A falsy expression is something which, when converted to a bool gives False. This includes empty lists, the number 0 and None; everything else is considered truthy. The full list is available in the documentation.\nIf it is truthy then nothing happens but if it is falsy then an exception is raised:\nassert 5 == 5\nassert 5 == 6\n---------------------------------------------------------------------------\n\nAssertionError                            Traceback (most recent call last)\n\n&lt;ipython-input-6-05598cd61862&gt; in &lt;module&gt;\n----&gt; 1 assert 5 == 6\n\n\nAssertionError: \nWe can now use this assert statement in place of the if/else block:\nfrom arrays import add_arrays\n\ndef test_add_arrays():\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n    expect = [5, 7, 9]\n    \n    output = add_arrays(a, b)\n    \n    assert output == expect\n\ntest_add_arrays()\nNow when we run the test script we get nothing printed on success:\n\n\nTerminal/Command Prompt\n\npython test_arrays.py\n\nbut on a failure we get an error printed like:\nTraceback (most recent call last):\n  File \"test_arrays.py\", line 13, in &lt;module&gt;\n    test_add_arrays()\n  File \"test_arrays.py\", line 11, in test_add_arrays\n    assert output == expect\nAssertionError\nWhich, like all exception messages gives us the location in the file at which the error occurred. This has the avantage that if we had many test functions being run it would tell us which one failed and on which line.\nThe downside of using an assert like this is that as soon as one test fails, the whole script will halt and you’ll only be informed of that one test.\n\n\npytest\nThere’s a few things that we’ve been doing so far that could be improved. Firstly, for every test function that we write we then have to explicitly call it at the bottom of the test script like test_add_arrays(). This is error-prone as we might write a test function and forget to call it and then we would miss any errors it would catch.\nSecondly, we want nice, useful output from our test functions. Something better than the nothing/exception that a plain assert gives us. It would be nice to get a green PASSED for the good tests and a red FAILED for the bad ones alongside the name of the test in question.\nFinally, we want to make sure that all tests are run even if a test early in the process fails.\nLuckily, there is tool called pytest which can give us all of these things. It will work on our test script almost exactly as written with only one change needed.\n\n\n\n\n\n\ncommand not found: pytest\n\n\n\nIf you don’t have pytest installed, try calling on the terminal pip install -U pytest.\n\n\nRemove the call to test_add_arrays() on the last line of the file:\nfrom arrays import add_arrays\n\ndef test_add_arrays():\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n    expect = [5, 7, 9]\n    \n    output = add_arrays(a, b)\n    \n    assert output == expect\nAnd in the Terminal, run pytest:\nCOLUMNS=60 pytest\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 1 item                                           \u001b[0m\n\ntest_arrays.py \u001b[32m.\u001b[0m\u001b[32m                                     [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 0.02s\u001b[0m\u001b[32m =====================\u001b[0m\nPytest will do two stages. First it will try to locate all the test functions that it can find and then it will run each of them in turn, reporting the results.\nHere you can see that it’s found that the file test_arrays.py contains a single test function. The green dot next to the name of the file signifies the passing test. It then prints a summary at the end saying “1 passed”.\nThe way that pytest works is that it looks for files which are called test_*.py or *_test.py and look inside those for functions whose names begin with test. It will then run those functions one at a time, reporting the results of each in turn.\nTo see what it looks like when you have a failing test, let’s deliberately break the test code by giving a wrong expected result:\nfrom arrays import add_arrays\n\ndef test_add_arrays():\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n    expect = [5, 7, 999]  # Changed this to break the test\n    \n    output = add_arrays(a, b)\n    \n    assert output == expect\nWhen we run this test with pytest it should tell us that the test is indeed failing:\nCOLUMNS=60 pytest\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 1 item                                           \u001b[0m\n\ntest_arrays.py \u001b[31mF\u001b[0m\u001b[31m                                     [100%]\u001b[0m\n\n========================= FAILURES =========================\n\u001b[31m\u001b[1m_____________________ test_add_arrays ______________________\u001b[0m\n\n    \u001b[94mdef\u001b[39;49;00m \u001b[92mtest_add_arrays\u001b[39;49;00m():\n        a = [\u001b[94m1\u001b[39;49;00m, \u001b[94m2\u001b[39;49;00m, \u001b[94m3\u001b[39;49;00m]\n        b = [\u001b[94m4\u001b[39;49;00m, \u001b[94m5\u001b[39;49;00m, \u001b[94m6\u001b[39;49;00m]\n        expect = [\u001b[94m5\u001b[39;49;00m, \u001b[94m7\u001b[39;49;00m, \u001b[94m999\u001b[39;49;00m]  \u001b[90m# Changed this to break the test\u001b[39;49;00m\n    \n        output = add_arrays(a, b)\n    \n&gt;       \u001b[94massert\u001b[39;49;00m output == expect\n\u001b[1m\u001b[31mE       assert [5, 7, 9] == [5, 7, 999]\u001b[0m\n\u001b[1m\u001b[31mE         At index 2 diff: 9 != 999\u001b[0m\n\u001b[1m\u001b[31mE         Use -v to get the full diff\u001b[0m\n\n\u001b[1m\u001b[31mtest_arrays.py\u001b[0m:11: AssertionError\n================= short test summary info ==================\nFAILED test_arrays.py::test_add_arrays - assert [5, 7, 9]...\n\u001b[31m==================== \u001b[31m\u001b[1m1 failed\u001b[0m\u001b[31m in 0.10s\u001b[0m\u001b[31m =====================\u001b[0m\nThe output from this is better than we saw with the plain assert. It’s printing the full context of the contents of the test function with the line where the assert is failing being marked with a &gt;. It then gives an expanded explanation of why the assert failed. Before we just got AssertionError but now it prints out the contents of output and expect and tells us that at index 2 of the list it’s finding a 9 where we told it to expect a 999.\nBefore continuing, make sure that you change the file back to its previous contents by changing that 999 back to a 9.\nfrom arrays import add_arrays\n\ndef test_add_arrays():\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n    expect = [5, 7, 9]  # Changed this back to 9\n    \n    output = add_arrays(a, b)\n    \n    assert output == expect\n\n\n\n\n\n\nExercise\n\n\n\nMake sure you can run the test as it is written here. See what happens when you make the test fail.\n\n\n\n\nAvoid repeating ourselves\nHaving a single test for a function is already infinitely better than having none, but one test only gives you so much confidence. The real power of a test suite is being able to test your functions under lots of different conditions.\nLets add a second test to check a different set of inputs and outputs to the add_arrays function and check that it passes:\n\nfrom arrays import add_arrays\n\ndef test_add_arrays1():\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n    expect = [5, 7, 9]\n    \n    output = add_arrays(a, b)\n    \n    assert output == expect\n\ndef test_add_arrays2():\n    a = [-1, -5, -3]\n    b = [-4, -3, 0]\n    expect = [-5, -8, -3]\n    \n    output = add_arrays(a, b)\n    \n    assert output == expect\nWhen we run pytest we can optionally pass the -v flag which puts it in verbose mode. This will print out the tests being run, one per line which I find a more useful view most of the time:\nCOLUMNS=60 pytest -v\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 2 items                                          \u001b[0m\n\ntest_arrays.py::test_add_arrays1 \u001b[32mPASSED\u001b[0m\u001b[32m              [ 50%]\u001b[0m\ntest_arrays.py::test_add_arrays2 \u001b[32mPASSED\u001b[0m\u001b[32m              [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m2 passed\u001b[0m\u001b[32m in 0.07s\u001b[0m\u001b[32m =====================\u001b[0m\nWe see both tests being run and passing. This will work well but we’ve had to repeat ourselves almost entirely in each test function. The only difference between the two functions is the inputs and outputs under test. Usually in this case in a normal Python function you would take these things as arguments and we can do the same thing here.\nThe actual logic of the function is the following:\ndef test_add_arrays(a, b, expect):\n    output = add_arrays(a, b)\n    assert output == expect\nWe then just need a way of passing the data we want to check into this function. Since we’re not explicitly calling this function ourselves, we need a way to tell pytest that it should pass in certain arguments. For this, pytest provides a feature called parametrisation. We label our function with a decoration which allows pytest to run it mutliple times with different data.\nTo use this feature we must import the pytest module and use the pytest.mark.parametrize decorator like the following:\n\nimport pytest\n\nfrom arrays import add_arrays\n\n@pytest.mark.parametrize(\"a, b, expect\", [\n    ([1, 2, 3],    [4, 5, 6],   [5, 7, 9]),\n    ([-1, -5, -3], [-4, -3, 0], [-5, -8, -3]),\n])\ndef test_add_arrays(a, b, expect):\n    output = add_arrays(a, b)\n    \n    assert output == expect\nThe parametrize decorator takes two arguments:\n\na string containing the names of the parameters you want to pass in (\"a, b, expect\")\na list containing the values of the arguments you want to pass in\n\nIn this case, the test will be run twice. Once with each of the following values:\n\na=[1, 2, 3], b=[4, 5, 6], expect=[5, 7, 9]\na=[-1, -5, -3], b=[-4, -3, 0], expect=[-5, -8, -3]\n\nCOLUMNS=60 pytest -v\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 2 items                                          \u001b[0m\n\ntest_arrays.py::test_add_arrays[a0-b0-expect0] \u001b[32mPASSED\u001b[0m\u001b[32m [ 50%]\u001b[0m\ntest_arrays.py::test_add_arrays[a1-b1-expect1] \u001b[32mPASSED\u001b[0m\u001b[32m [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m2 passed\u001b[0m\u001b[32m in 0.03s\u001b[0m\u001b[32m =====================\u001b[0m\nRunning pytest we see that both tests have the same name (test_arrays.py::test_add_arrays) but each parametrisation is differentiated with some square brackets.\n\n\n\n\n\n\nExercise\n\n\n\nAdd some more parameters sets to the test_add_arrays function. Try to think about corner-cases that might make the function fail. It’s your job as the tester to try to “break” the code.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\"\"\"\nThis module contains functions for manipulating and combining Python lists.\n\"\"\"\n\ndef add_arrays(x, y):\n    \"\"\"\n    This function adds together each element of the two passed lists.\n\n    Args:\n        x (list): The first list to add\n        y (list): The second list to add\n\n    Returns:\n        list: the pairwise sums of ``x`` and ``y``.\n\n    Examples:\n        &gt;&gt;&gt; add_arrays([1, 4, 5], [4, 3, 5])\n        [5, 7, 10]\n    \"\"\"\n    z = []\n    for x_, y_ in zip(x, y):\n        z.append(x_ + y_)\n\n    return z\n\nimport pytest\n\nfrom arrays import add_arrays\n\n@pytest.mark.parametrize(\"a, b, expect\", [\n    ([1, 2, 3], [4, 5, 6], [5, 7, 9]),\n    ([-1, -5, -3], [-4, -3, 0], [-5, -8, -3]),\n    ([41, 0, 3], [4, 76, 32], [45, 76, 35]),\n    ([], [], []),\n])\ndef test_add_arrays(a, b, expect):\n    output = add_arrays(a, b)\n    \n    assert output == expect\nCOLUMNS=60 pytest test_arrays.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: attrib-0.1.3, requests-mock-1.8.0, cov-2.10.1, hypothesis-5.24.2\ncollected 4 items                                          \u001b[0m\n\ntest_arrays.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m                                  [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m4 passed\u001b[0m\u001b[32m in 0.01s\u001b[0m\u001b[32m =====================\u001b[0m\n\n\n\n\n\nFailing correctly\nThe interface of a function is made up of the parameters it expects and the values that it returns. If a user of a function knows these things then they are able to use it correctly. This is why we make sure to include this information in the docstring for all our functions.\nThe other thing that is part of the interface of a function is any exceptions that are raised by it. If you need a refresher on exceptions and error handling in Python, take a look at the chapter on it in the Intermediate Python course.\nTo add explicit error handling to our function we need to do two things: 1. add in a conditional raise statement:\nif len(x) != len(y):\n    raise ValueError(\"Both arrays must have the same length.\")\n\ndocument in the docstring the fact that the function may raise something:\nRaises:\n    ValueError: If the length of the lists ``x`` and ``y`` are different.\n\nLet’s add these to arrays.py:\n\"\"\"\nThis module contains functions for manipulating and combining Python lists.\n\"\"\"\n\ndef add_arrays(x, y):\n    \"\"\"\n    This function adds together each element of the two passed lists.\n\n    Args:\n        x (list): The first list to add\n        y (list): The second list to add\n\n    Returns:\n        list: the pairwise sums of ``x`` and ``y``.\n    \n    Raises:\n        ValueError: If the length of the lists ``x`` and ``y`` are different.\n\n    Examples:\n        &gt;&gt;&gt; add_arrays([1, 4, 5], [4, 3, 5])\n        [5, 7, 10]\n    \"\"\"\n    \n    if len(x) != len(y):\n        raise ValueError(\"Both arrays must have the same length.\")\n    \n    z = []\n    for x_, y_ in zip(x, y):\n        z.append(x_ + y_)\n\n    return z\nWe can then test that the function correctly raises the exception when passed appropriate data. Inside a pytest function we can require that a specific exception is raised by using pytest.raises in a with block. pytest.raises takes as an argument the type of an exception and if the block ends without that exception having been rasied, will fail the test.\nIt may seem strange that we’re testing-for and requiring that the function raises an error but it’s important that if we’ve told our users that the code will produce a certain error in specific circumstances that it does indeed do as we promise.\nIn our code we add a new test called test_add_arrays_error which does the check we require:\nimport pytest\n\nfrom arrays import add_arrays\n\n@pytest.mark.parametrize(\"a, b, expect\", [\n    ([1, 2, 3],    [4, 5, 6],   [5, 7, 9]),\n    ([-1, -5, -3], [-4, -3, 0], [-5, -8, -3]),\n])\ndef test_add_arrays(a, b, expect):\n    output = add_arrays(a, b)\n    \n    assert output == expect\n\ndef test_add_arrays_error():\n    a = [1, 2, 3]\n    b = [4, 5]\n    with pytest.raises(ValueError):\n        output = add_arrays(a, b)\nCOLUMNS=60 pytest -v\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 3 items                                          \u001b[0m\n\ntest_arrays.py::test_add_arrays[a0-b0-expect0] \u001b[32mPASSED\u001b[0m\u001b[32m [ 33%]\u001b[0m\ntest_arrays.py::test_add_arrays[a1-b1-expect1] \u001b[32mPASSED\u001b[0m\u001b[32m [ 66%]\u001b[0m\ntest_arrays.py::test_add_arrays_error \u001b[32mPASSED\u001b[0m\u001b[32m         [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m3 passed\u001b[0m\u001b[32m in 0.03s\u001b[0m\u001b[32m =====================\u001b[0m\n\n\n\n\n\n\nExercise\n\n\n\n\nMake sure you can run the test_add_arrays_error test and that it passes.\nIf you have time, try parametrising the test_add_arrays_error test fuction.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\"\"\"\nThis module contains functions for manipulating and combining Python lists.\n\"\"\"\n\ndef add_arrays(x, y):\n    \"\"\"\n    This function adds together each element of the two passed lists.\n\n    Args:\n        x (list): The first list to add\n        y (list): The second list to add\n\n    Returns:\n        list: the pairwise sums of ``x`` and ``y``.\n    \n    Raises:\n        ValueError: If the length of the lists ``x`` and ``y`` are different.\n\n    Examples:\n        &gt;&gt;&gt; add_arrays([1, 4, 5], [4, 3, 5])\n        [5, 7, 10]\n    \"\"\"\n\n    if len(x) != len(y):\n        raise ValueError(\"Both arrays must have the same length.\")\n\n    z = []\n    for x_, y_ in zip(x, y):\n        z.append(x_ + y_)\n\n    return z\n\nimport pytest\n\nfrom arrays import add_arrays\n\ndef test_add_arrays_error():\n    a = [1, 2, 3]\n    b = [4, 5]\n    with pytest.raises(ValueError):\n        output = add_arrays(a, b)\nCOLUMNS=60 pytest test_arrays.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: attrib-0.1.3, requests-mock-1.8.0, cov-2.10.1, hypothesis-5.24.2\ncollected 1 item                                           \u001b[0m\n\ntest_arrays.py \u001b[32m.\u001b[0m\u001b[32m                                     [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 0.01s\u001b[0m\u001b[32m =====================\u001b[0m\n\nimport pytest\n\nfrom arrays import add_arrays\n\n@pytest.mark.parametrize(\"a, b\", [\n    ([1, 2, 3], [4, 5]),\n    ([1, 2], [4, 5, 6]),\n    ([], [4]),\n    ([4], []),\n])\ndef test_add_arrays_error(a, b):\n    a = [1, 2, 3]\n    b = [4, 5]\n    with pytest.raises(ValueError):\n        output = add_arrays(a, b)\nCOLUMNS=60 pytest test_arrays.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: attrib-0.1.3, requests-mock-1.8.0, cov-2.10.1, hypothesis-5.24.2\ncollected 4 items                                          \u001b[0m\n\ntest_arrays.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m                                  [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m4 passed\u001b[0m\u001b[32m in 0.01s\u001b[0m\u001b[32m =====================\u001b[0m\n\n\n\n\n\nDoctests\nIf you remember from when we were documenting our add_arrays function, we had a small section which gave the reader an example of how to use the function:\nExamples:\n    &gt;&gt;&gt; add_arrays([1, 4, 5], [4, 3, 5])\n    [5, 7, 10]\nSince this is valid Python code, we can ask pytest to run this code and check that the output we claimed would be returned is correct. If we pass --doctest-modules to the pytest command, it will search .py files for docstrings with example blocks and run them:\nCOLUMNS=60 pytest -v --doctest-modules\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 4 items                                          \u001b[0m\n\narrays.py::arrays.add_arrays \u001b[32mPASSED\u001b[0m\u001b[32m                  [ 25%]\u001b[0m\ntest_arrays.py::test_add_arrays[a0-b0-expect0] \u001b[32mPASSED\u001b[0m\u001b[32m [ 50%]\u001b[0m\ntest_arrays.py::test_add_arrays[a1-b1-expect1] \u001b[32mPASSED\u001b[0m\u001b[32m [ 75%]\u001b[0m\ntest_arrays.py::test_add_arrays_error \u001b[32mPASSED\u001b[0m\u001b[32m         [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m4 passed\u001b[0m\u001b[32m in 0.18s\u001b[0m\u001b[32m =====================\u001b[0m\nWe see here the arrays.py::arrays.add_arrays test which has passed. If you get a warning about deprecation then ignore it, this is from a third-party module which is leaking through.\nDoctests are a really valuable thing to have in your test suite as they ensure that any examples that you are giving work as expected. It’s not uncommon for the code to change and for the documentation to be left behind and being able to automatically check all your examples avoids this.\n\n\n\n\n\n\nExercise\n\n\n\nSee what happens when you break your doctest and run pytest again.\n\n\n\n\nRunning specific tests\nAs you increase the number of tests you will come across situations where you only want to run a particular test. To do this, you follow pass the name of the test, as printed by pytest -v as an argument to pytest. So, if we want to run all tests in test_arrays.py we do:\nCOLUMNS=60 pytest -v test_arrays.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 3 items                                          \u001b[0m\n\ntest_arrays.py::test_add_arrays[a0-b0-expect0] \u001b[32mPASSED\u001b[0m\u001b[32m [ 33%]\u001b[0m\ntest_arrays.py::test_add_arrays[a1-b1-expect1] \u001b[32mPASSED\u001b[0m\u001b[32m [ 66%]\u001b[0m\ntest_arrays.py::test_add_arrays_error \u001b[32mPASSED\u001b[0m\u001b[32m         [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m3 passed\u001b[0m\u001b[32m in 0.01s\u001b[0m\u001b[32m =====================\u001b[0m\nOr, if we want to specifically run the test_add_arrays test:\nCOLUMNS=60 pytest -v test_arrays.py::test_add_arrays\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 2 items                                          \u001b[0m\n\ntest_arrays.py::test_add_arrays[a0-b0-expect0] \u001b[32mPASSED\u001b[0m\u001b[32m [ 50%]\u001b[0m\ntest_arrays.py::test_add_arrays[a1-b1-expect1] \u001b[32mPASSED\u001b[0m\u001b[32m [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m2 passed\u001b[0m\u001b[32m in 0.01s\u001b[0m\u001b[32m =====================\u001b[0m\nOr, if we want to run one test specifically:\nCOLUMNS=60 pytest -v \"test_arrays.py::test_add_arrays[a0-b0-expect0]\"\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 1 item                                           \u001b[0m\n\ntest_arrays.py::test_add_arrays[a0-b0-expect0] \u001b[32mPASSED\u001b[0m\u001b[32m [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 0.01s\u001b[0m\u001b[32m =====================\u001b[0m\nTake a look at the output of pytest -h for more options. For example, you can tell pytest to only run the tests that failed on the last run with pytest --last-failed.\n\n\nTesting during development\nWhen developing code I recommend starting your day by running the test suite. This gives you confidence in the code before you start playing around with it. Then after each set of changes, run the tests again to make sure that you have not broken anything.\nAs you add new feature and functions to your code, add tests for them straight away. Doing this while the code logic is fresh in your mind will make the test writing much easier. Even better is to write the tests for the code directly alongside the new function. This gives you a structured way of checking your function while you work on it. You’re likely doing manual testing of your code as you write it anyway so why not automate it so that once you’re finished you’ve improved your test suite for free!\nSome people go a step further and follow a process called test-driven development where the first thing you do is write the docstring for the function, describing what the function will take as arguments and what it will return. Once you know that, you can write a test which will, in principle, pass if the function does as described. Only then will they go ahead and write the body of the function and once the test passes, their job is done.\nThese techniques are part of a spectrum so find the place on it which makes you the most productive in the long-term. When I started programming I never wrote tests but as I’ve progressed I’ve found that they make writing correct code much easier and I couldn’t write software without them. You will likely find a progression towards a more structured approach over time.\nYou don’t need to worry over covering every single line of code with tests. If you have zero tests then you have effectively zero confidence that your code works. As soon as you add a single one, your confidence starts growing. The more you add, the safer you are. There’s no magic number of tests.\n\n\nAutomated tests\nWe will not cover it in this course but once you have a good test suite and if your source code is hosted on a public Git website then you can make it so that the tests of your code are automatically run on every change. As long as you commit your test_*.py to Git files then with a few lines of config you are able to make it run your tests for you. This is especially useful once you are collaborating with other people as the atuomated tests will give you confidence that the new feature your colleage is adding has not broken the code you wrote last week for example.",
    "crumbs": [
      "Testing"
    ]
  },
  {
    "objectID": "pages/070-worksheet.html",
    "href": "pages/070-worksheet.html",
    "title": "Worksheet",
    "section": "",
    "text": "This page contains a number of questions and exercises to give you a chance to practise what you have learned this session. You should create a new .py Python file for each exercise.\nWe’ve now covered all the topics on this course so to finish off, work through this final exercise. It is designed to give you a chance to pratise what you’ve learned on some new code.\nMake a new directory alongside the bestpractices folder called crypto. In the Terminal change to that directory with cd ../crypto and in the Python Console change there with %cd ../crypto. In that directory make two new files called morse.py and test_morse.py:\n# A lookup dictionary which, given a letter will return the morse code equivalent\n_letter_to_morse = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n                   'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n                   'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n                   'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n                   '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n                   '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.',\n                   ' ':'/'}\n\n# This will create a dictionary that can go from the morse back to the letter\n_morse_to_letter = {}\nfor letter in _letter_to_morse:\n    morse = _letter_to_morse[letter]\n    _morse_to_letter[morse] = letter\n\n\ndef encode(message):\n    morse = []\n\n    for letter in message:\n        letter = letter.lower()\n        morse.append(_letter_to_morse[letter])\n\n    # We need to join together Morse code letters with spaces\n    morse_message = \" \".join(morse)\n    \n    return morse_message\n\n\ndef decode(message):\n    english = []\n\n    # Now we cannot read by letter. We know that morse letters are\n    # separated by a space, so we split the morse string by spaces\n    morse_letters = message.split(\" \")\n\n    for letter in morse_letters:\n        english.append(_morse_to_letter[letter])\n\n    # Rejoin, but now we don't need to add any spaces\n    english_message = \"\".join(english)\n    \n    return english_message\nOverwriting morse.py\nfrom morse import encode, decode\n\ndef test_encode():\n    assert encode(\"SOS\") == \"... --- ...\"\nThis module is designed to convert message to and from Morse code. It provides one function which takes an English message and converts it to a Morse code string, separated by spaces and another function which takes the Morse code string and converts it to English.\n\n\n\n\n\n\nExercise\n\n\n\nAdd documentation to the morse module and to the encode and decode functions. Make sure you detail the inputs, outputs and give an example of their usage. Look at the tests to get an idea of how it works or try importing morse in the Python Console and have a play with the functions to understand them.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# A lookup dictionary which, given a letter will return the morse code equivalent\n_letter_to_morse = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n                   'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n                   'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n                   'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n                   '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n                   '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.',\n                   ' ':'/'}\n\n# This will create a dictionary that can go from the morse back to the letter\n_morse_to_letter = {}\nfor letter in _letter_to_morse:\n    morse = _letter_to_morse[letter]\n    _morse_to_letter[morse] = letter\n\n\ndef encode(message):\n    \"\"\"\n    Encode a message from English to Morse Code\n    \n    Args:\n        message (str): the English message to encode\n    \n    Returns:\n        str: The encoded message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\"Help us\")\n        \".... . .-.. .--. / ..- ...\"\n    \"\"\"\n    morse = []\n\n    for letter in message:\n        letter = letter.lower()\n        morse.append(_letter_to_morse[letter])\n\n    # We need to join together Morse code letters with spaces\n    morse_message = \" \".join(morse)\n    \n    return morse_message\n\n\ndef decode(message):\n    \"\"\"\n    Decode a message from Morse Code to English\n    \n    Args:\n        message (str): the Morse Code message to decode\n    \n    Returns:\n        str: The decoded English message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\".... . .-.. .--. / ..- ...\")\n        \"help us\"\n    \"\"\"\n    english = []\n\n    # Now we cannot read by letter. We know that morse letters are\n    # separated by a space, so we split the morse string by spaces\n    morse_letters = message.split(\" \")\n\n    for letter in morse_letters:\n        english.append(_morse_to_letter[letter])\n\n    # Rejoin, but now we don't need to add any spaces\n    english_message = \"\".join(english)\n    \n    return english_message\nWriting morse.py\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\nAdd a test for the decode function to test_morse.py and check it passes with pytest\nParametrise both tests to give several examples. Make sure you include upper and lower case letters as well as checking what happens if you pass in empty strings\nMake sure to use --doctest-modules to run the documentation examples that you added in the last exercise\nHint: When writing doctests, it cares whether your test output uses single or double quotes (' or \"). Use single quotes for doctest outputs.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# A lookup dictionary which, given a letter will return the morse code equivalent\n_letter_to_morse = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n                   'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n                   'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n                   'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n                   '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n                   '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.',\n                   ' ':'/'}\n\n# This will create a dictionary that can go from the morse back to the letter\n_morse_to_letter = {}\nfor letter in _letter_to_morse:\n    morse = _letter_to_morse[letter]\n    _morse_to_letter[morse] = letter\n\n\ndef encode(message):\n    \"\"\"\n    Encode a message from English to Morse Code\n    \n    Args:\n        message (str): the English message to encode\n    \n    Returns:\n        str: The encoded message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\"Help us\")\n        '.... . .-.. .--. / ..- ...'\n    \"\"\"\n    morse = []\n\n    for letter in message:\n        letter = letter.lower()\n        morse.append(_letter_to_morse[letter])\n\n    # We need to join together Morse code letters with spaces\n    morse_message = \" \".join(morse)\n    \n    return morse_message\n\n\ndef decode(message):\n    \"\"\"\n    Decode a message from Morse Code to English\n    \n    Args:\n        message (str): the Morse Code message to decode\n    \n    Returns:\n        str: The decoded English message\n    \n    Examples:\n        &gt;&gt;&gt; decode(\".... . .-.. .--. / ..- ...\")\n        'help us'\n    \"\"\"\n    english = []\n\n    # Now we cannot read by letter. We know that morse letters are\n    # separated by a space, so we split the morse string by spaces\n    morse_letters = message.split(\" \")\n\n    for letter in morse_letters:\n        english.append(_morse_to_letter[letter])\n\n    # Rejoin, but now we don't need to add any spaces\n    english_message = \"\".join(english)\n    \n    return english_message\nOverwriting morse.py\n\nimport pytest\n\nfrom morse import encode, decode\n\n@pytest.mark.parametrize(\"message, output\", [\n    (\"SOS\", \"... --- ...\"),\n    (\"help\", \".... . .-.. .--.\"),\n    (\"\", \"\"),\n    (\" \", \"/\"),\n])\ndef test_encode(message, output):\n    assert encode(message) == output\n\n@pytest.mark.parametrize(\"message, output\", [\n    (\"... --- ...\", \"sos\"),\n    (\".... . .-.. .--.\", \"help\"),\n    (\"/\", \" \"),\n])\ndef test_decode(message, output):\n    assert decode(message) == output\nOverwriting test_morse.py\nCOLUMNS=60 pytest -v --doctest-modules morse.py test_morse.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 9 items                                          \u001b[0m\n\nmorse.py::morse.decode \u001b[32mPASSED\u001b[0m\u001b[32m                        [ 11%]\u001b[0m\nmorse.py::morse.encode \u001b[32mPASSED\u001b[0m\u001b[32m                        [ 22%]\u001b[0m\ntest_morse.py::test_encode[SOS-... --- ...] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 33%]\u001b[0m\ntest_morse.py::test_encode[help-.... . .-.. .--.] \u001b[32mPASSED\u001b[0m\u001b[32m [ 44%]\u001b[0m\ntest_morse.py::test_encode[-] \u001b[32mPASSED\u001b[0m\u001b[32m                 [ 55%]\u001b[0m\ntest_morse.py::test_encode[ -/] \u001b[32mPASSED\u001b[0m\u001b[32m               [ 66%]\u001b[0m\ntest_morse.py::test_decode[... --- ...-sos] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 77%]\u001b[0m\ntest_morse.py::test_decode[.... . .-.. .--.-help] \u001b[32mPASSED\u001b[0m\u001b[32m [ 88%]\u001b[0m\ntest_morse.py::test_decode[/- ] \u001b[32mPASSED\u001b[0m\u001b[32m               [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m9 passed\u001b[0m\u001b[32m in 0.04s\u001b[0m\u001b[32m =====================\u001b[0m\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\nWhat happens if you pass in the string \"Don't forget to save us\" to encode?\n\nHint: The problem is caused by the ' in the string\n\nEdit morse.py to raise a ValueError in this situation instead.\nWrite a test to make sure that the ValueError is raised when a string with a ' is passed in.\nParametrise that test with some other examples including the & and £ characters.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# A lookup dictionary which, given a letter will return the morse code equivalent\n_letter_to_morse = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n                   'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n                   'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n                   'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n                   '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n                   '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.',\n                   ' ':'/'}\n\n# This will create a dictionary that can go from the morse back to the letter\n_morse_to_letter = {}\nfor letter in _letter_to_morse:\n    morse = _letter_to_morse[letter]\n    _morse_to_letter[morse] = letter\n\n\ndef encode(message):\n    \"\"\"\n    Encode a message from English to Morse Code\n    \n    Args:\n        message (str): the English message to encode\n    \n    Returns:\n        str: The encoded message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\"Help us\")\n        '.... . .-.. .--. / ..- ...'\n    \"\"\"\n    morse = []\n\n    for letter in message:\n        letter = letter.lower()\n        \n        if letter not in _letter_to_morse:\n            raise ValueError(f\"Cannot encode \\\"{message}\\\". Character \\\"{letter}\\\" not in Morse dictionary\")\n        \n        morse.append(_letter_to_morse[letter])\n\n    # We need to join together Morse code letters with spaces\n    morse_message = \" \".join(morse)\n    \n    return morse_message\n\n\ndef decode(message):\n    \"\"\"\n    Decode a message from Morse Code to English\n    \n    Args:\n        message (str): the Morse Code message to decode\n    \n    Returns:\n        str: The decoded English message\n    \n    Examples:\n        &gt;&gt;&gt; decode(\".... . .-.. .--. / ..- ...\")\n        'help us'\n    \"\"\"\n    english = []\n\n    # Now we cannot read by letter. We know that morse letters are\n    # separated by a space, so we split the morse string by spaces\n    morse_letters = message.split(\" \")\n\n    for letter in morse_letters:\n        english.append(_morse_to_letter[letter])\n\n    # Rejoin, but now we don't need to add any spaces\n    english_message = \"\".join(english)\n    \n    return english_message\n\nimport pytest\n\nfrom morse import encode, decode\n\n@pytest.mark.parametrize(\"message, output\", [\n    (\"SOS\", \"... --- ...\"),\n    (\"help\", \".... . .-.. .--.\"),\n    (\"\", \"\"),\n    (\" \", \"/\"),\n])\ndef test_encode(message, output):\n    assert encode(message) == output\n\n@pytest.mark.parametrize(\"message, output\", [\n    (\"... --- ...\", \"sos\"),\n    (\".... . .-.. .--.\", \"help\"),\n    (\"/\", \" \"),\n])\ndef test_decode(message, output):\n    assert decode(message) == output\n\ndef test_error():  # New test\n    with pytest.raises(ValueError):\n        encode(\"Don't forget to save us\")\n\n@pytest.mark.parametrize(\"message\", [\n    \"It's sinking\",\n    \"Titanic & Olympic\",\n    \"This boat is expensive £££\",\n    \"Help!\",\n])\ndef test_errors(message):  # New test\n    with pytest.raises(ValueError):\n        encode(message)\nOverwriting test_morse.py\nCOLUMNS=60 pytest -v --doctest-modules morse.py test_morse.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.2, py-1.9.0, pluggy-0.13.1 -- /home/matt/projects/courses/software_engineering_best_practices/venv/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: nbval-0.9.6\ncollected 14 items                                         \u001b[0m\n\nmorse.py::morse.decode \u001b[32mPASSED\u001b[0m\u001b[32m                        [  7%]\u001b[0m\nmorse.py::morse.encode \u001b[32mPASSED\u001b[0m\u001b[32m                        [ 14%]\u001b[0m\ntest_morse.py::test_encode[SOS-... --- ...] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 21%]\u001b[0m\ntest_morse.py::test_encode[help-.... . .-.. .--.] \u001b[32mPASSED\u001b[0m\u001b[32m [ 28%]\u001b[0m\ntest_morse.py::test_encode[-] \u001b[32mPASSED\u001b[0m\u001b[32m                 [ 35%]\u001b[0m\ntest_morse.py::test_encode[ -/] \u001b[32mPASSED\u001b[0m\u001b[32m               [ 42%]\u001b[0m\ntest_morse.py::test_decode[... --- ...-sos] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 50%]\u001b[0m\ntest_morse.py::test_decode[.... . .-.. .--.-help] \u001b[32mPASSED\u001b[0m\u001b[32m [ 57%]\u001b[0m\ntest_morse.py::test_decode[/- ] \u001b[32mPASSED\u001b[0m\u001b[32m               [ 64%]\u001b[0m\ntest_morse.py::test_error \u001b[32mPASSED\u001b[0m\u001b[32m                     [ 71%]\u001b[0m\ntest_morse.py::test_errors[It's sinking] \u001b[32mPASSED\u001b[0m\u001b[32m      [ 78%]\u001b[0m\ntest_morse.py::test_errors[Titanic & Olympic] \u001b[32mPASSED\u001b[0m\u001b[32m [ 85%]\u001b[0m\ntest_morse.py::test_errors[This boat is expensive \\xa3\\xa3\\xa3] \u001b[32mPASSED\u001b[0m\u001b[32m [ 92%]\u001b[0m\ntest_morse.py::test_errors[Help!] \u001b[32mPASSED\u001b[0m\u001b[32m             [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m14 passed\u001b[0m\u001b[32m in 0.03s\u001b[0m\u001b[32m ====================\u001b[0m\n\n\n\nopen(./assets)",
    "crumbs": [
      "Worksheet"
    ]
  },
  {
    "objectID": "pages/answer_final_morse_doc.html",
    "href": "pages/answer_final_morse_doc.html",
    "title": "Best Practices in Software Engineering",
    "section": "",
    "text": "# A lookup dictionary which, given a letter will return the morse code equivalent\n_letter_to_morse = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n                   'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n                   'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n                   'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n                   '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n                   '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.',\n                   ' ':'/'}\n\n# This will create a dictionary that can go from the morse back to the letter\n_morse_to_letter = {}\nfor letter in _letter_to_morse:\n    morse = _letter_to_morse[letter]\n    _morse_to_letter[morse] = letter\n\n\ndef encode(message):\n    \"\"\"\n    Encode a message from English to Morse Code\n    \n    Args:\n        message (str): the English message to encode\n    \n    Returns:\n        str: The encoded message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\"Help us\")\n        \".... . .-.. .--. / ..- ...\"\n    \"\"\"\n    morse = []\n\n    for letter in message:\n        letter = letter.lower()\n        morse.append(_letter_to_morse[letter])\n\n    # We need to join together Morse code letters with spaces\n    morse_message = \" \".join(morse)\n    \n    return morse_message\n\n\ndef decode(message):\n    \"\"\"\n    Decode a message from Morse Code to English\n    \n    Args:\n        message (str): the Morse Code message to decode\n    \n    Returns:\n        str: The decoded English message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\".... . .-.. .--. / ..- ...\")\n        \"help us\"\n    \"\"\"\n    english = []\n\n    # Now we cannot read by letter. We know that morse letters are\n    # separated by a space, so we split the morse string by spaces\n    morse_letters = message.split(\" \")\n\n    for letter in morse_letters:\n        english.append(_morse_to_letter[letter])\n\n    # Rejoin, but now we don't need to add any spaces\n    english_message = \"\".join(english)\n    \n    return english_message\nWriting morse.py"
  },
  {
    "objectID": "pages/990-contributors.html",
    "href": "pages/990-contributors.html",
    "title": "Contributors",
    "section": "",
    "text": "This course was originally written by Matt Williams, see https://milliams.com/courses/software_engineering_best_practices/.\nThe course has since been modified by the Jean Golding Institute.",
    "crumbs": [
      "Contributors"
    ]
  },
  {
    "objectID": "pages/020-documentation.html",
    "href": "pages/020-documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "In previous sessions you have learned how to package code into functions and to package functions into modules. Functions and modules let you design, write and package your code so that it is easy to understand and easily reusable. However, to share the code, and allow users to really understand how it works, you need to add documentation.\nYou can access the documentation for any object using the Python help function or using ? in the interactive Python console. For example, lets look at the documentation for the print function that we have used many times. Go to the Console and run:\nprint?\nit should return something that looks like:\nDocstring:\nprint(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\nPrints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile:  a file-like object (stream); defaults to the current sys.stdout.\nsep:   string inserted between values, default a space.\nend:   string appended after the last value, default a newline.\nflush: whether to forcibly flush the stream.\nType:      builtin_function_or_method\nThis docstring as it calls it (for documentation string) is a human-written piece of text which is there to help you, the programmer, know how to use the function.\nThe ? syntax is an iPython-specific thing but you can use the equivalent help function anywhere. If you run:\nhelp(print)\nHelp on built-in function print in module builtins:\n\nprint(...)\n    print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n    \n    Prints the values to a stream, or to sys.stdout by default.\n    Optional keyword arguments:\n    file:  a file-like object (stream); defaults to the current sys.stdout.\n    sep:   string inserted between values, default a space.\n    end:   string appended after the last value, default a newline.\n    flush: whether to forcibly flush the stream.\nthen you should see a very similar output.\nThroughout this chapter we will be learning how to make our own docstrings and how to create nice readable documentation web pages.\n\nDocumenting our own functions\nLet’s start by writing a simple function in a module by itself which we can import and use. To begin we’ll explore this in the Python Console and then we’ll move onto putting this code into a module. For this example we’ll use the add_arrays function from previous courses. Type the following into the Python Console:\ndef add_arrays(x, y):\n    z = []\n    for x_elem, y_elem in zip(x, y):\n        z.append(x_elem + y_elem)\n    return z\nTo see what the documentation for this function is, we either type add_arrays? or:\nhelp(add_arrays)\nHelp on function add_arrays in module __main__:\n\nadd_arrays(x, y)\nBy default, the only documentation available for a function is just a repeat of whatever we wrote on the def line, so we see the name of the function along with the parameters available for it.\nIf we want to give the user some more information, we can pass it is by putting a string as the first thing inside the function. By convention we use a triple-quoted string which both starts and ends with three \" in a row as they allow you to have strings over multiple lines:\ndef add_arrays(x, y):\n    \"\"\"\n    This function adds together each element of the two\n    passed lists, returning the result in the returned list.\n    \"\"\"\n    z = []\n    for x_elem, y_elem in zip(x, y):\n        z.append(x_elem + y_elem)\n    return z\nNow, when we ask for the documentation, we should see our docstring printed:\nhelp(add_arrays)\nHelp on function add_arrays in module __main__:\n\nadd_arrays(x, y)\n    This function adds together each element of the two\n    passed lists, returning the result in the returned list.\nYou can write whatever text you like in the documentation string, the most important thing is that you give the users of your code the information they need. Useful information for a user of the function are things like:\n\nWhat arguments it takes\nWhat it returns\nAn example of how to use it\n\nThere are a number of different conventions of how to format documentation strings but a common one is the Google style which looks like:\ndef add_arrays(x, y):\n    \"\"\"\n    This function adds together each element of the two passed lists.\n\n    Args:\n        x (list): The first list to add\n        y (list): The second list to add\n\n    Returns:\n        list: the pairwise sums of ``x`` and ``y``.\n\n    Examples:\n        &gt;&gt;&gt; add_arrays([1, 4, 5], [4, 3, 5])\n        [5, 7, 10]\n    \"\"\"\n    z = []\n    for x_, y_ in zip(x, y):\n        z.append(x_ + y_)\n\n    return z\nWe can check that this works by again doing:\nhelp(add_arrays)\nHelp on function add_arrays in module __main__:\n\nadd_arrays(x, y)\n    This function adds together each element of the two passed lists.\n    \n    Args:\n        x (list): The first list to add\n        y (list): The second list to add\n    \n    Returns:\n        list: the pairwise sums of ``x`` and ``y``.\n    \n    Examples:\n        &gt;&gt;&gt; add_arrays([1, 4, 5], [4, 3, 5])\n        [5, 7, 10]\nThis is a lot more information and it might seem strange that the documentation is longer than the code it describes but it’s very important that you give the user of your code all the information that they need in order to use it. Remember, your documentation is only going to be written once but it will be read many times so it’s worth spending the time on it.\nIn this example we have given a short one-line description of what the function does. Then we explicitly listed all of the arguments to the function along with what type they expect. After that we specified the type and description of the return value. Finally, and importantly we give an example to the user of how the function can be called and the output that it will give. The &gt;&gt;&gt; go in front of the line of calling Python code and the return value is on the line after.\nYou can find more examples of the Google documentation style in the official Sphinx documentation.\n\n\nDocumenting modules\nAs well as functions, we can document whole modules. To do this, we’ll have to move our function into a file called arrays.py. From previous courses, you should remember that this will make a module called arrays which we can import.\nTo document a module you use the same triple-quoted string as in functions but this time it goes at the very top of the file.\nIn the file editor, make a file called arrays.py in the bestpractices folder and put the following in it:\n\"\"\"\nThis module contains functions for manipulating and combining Python lists.\n\"\"\"\n\ndef add_arrays(x, y):\n    \"\"\"\n    This function adds together each element of the two passed lists.\n\n    Args:\n        x (list): The first list to add\n        y (list): The second list to add\n\n    Returns:\n        list: the pairwise sums of ``x`` and ``y``.\n\n    Examples:\n        &gt;&gt;&gt; add_arrays([1, 4, 5], [4, 3, 5])\n        [5, 7, 10]\n    \"\"\"\n    z = []\n    for x_, y_ in zip(x, y):\n        z.append(x_ + y_)\n\n    return z\nWe can then import the module in the Python Console:\nimport arrays\nIf you get an import error, the Console may be looking in the wrong folder. Move to the correct folder using % cd bestpractices.\nOnce it is imported we can get the documentation for the function with:\nhelp(arrays.add_arrays)\nHelp on function add_arrays in module arrays:\n\nadd_arrays(x, y)\n    This function adds together each element of the two passed lists.\n    \n    Args:\n        x (list): The first list to add\n        y (list): The second list to add\n    \n    Returns:\n        list: the pairwise sums of ``x`` and ``y``.\n    \n    Examples:\n        &gt;&gt;&gt; add_arrays([1, 4, 5], [4, 3, 5])\n        [5, 7, 10]\nBut we can also get the documentation for the whole module with:\nhelp(arrays)\nHelp on module arrays:\n\nNAME\n    arrays - This module contains functions for manipulating and combining Python lists.\n\nFUNCTIONS\n    add_arrays(x, y)\n        This function adds together each element of the two passed lists.\n        \n        Args:\n            x (list): The first list to add\n            y (list): The second list to add\n        \n        Returns:\n            list: the pairwise sums of ``x`` and ``y``.\n        \n        Examples:\n            &gt;&gt;&gt; add_arrays([1, 4, 5], [4, 3, 5])\n            [5, 7, 10]\n\nFILE\n    /home/matt/projects/courses/software_engineering_best_practices/arrays.py\nYou’ll see in this case that it’s showing the overall module docstring as well as those for the functions inside it.\n\n\n\n\n\n\nExercise\n\n\n\nRun the example code from the documentation in the Console. Make sure that you are seeing the same output as shown in the docs. - hint: remember that the add_arrays function is inside the arrays module so you either have to import it as from arrays import add_arrays or run it with arrays.add_arrays.\n\n\n\n\nDocumentation-driven-development\nIt’s always worth writing some documentation for each of your functions but you can go a step further and use a method known as documentation-driven-development. In this model you write the function signature and documentation for the function first, before writing any of the code inside it. This encourages you to think ahead of time about exactly what your function will do, how it will be called by users and what you expect it to return.\n\n\nGenerating documentation web pages\nAs well as viewing your documentation in the Python Console, it’s possible to automatically create web pages to share your documentation. This is not a necessary part of this course but if you are interested later, have a look at the appendix on the tool Sphinx.",
    "crumbs": [
      "Documentation"
    ]
  },
  {
    "objectID": "pages/040-testing-data.html",
    "href": "pages/040-testing-data.html",
    "title": "Input data for tests",
    "section": "",
    "text": "As we saw in the last section, when using parametrisation it’s often useful to split your test function into two logical parts:\n\nThe data to be tested\nThe code to do the test\n\nThis is because we had a situation where we had one test function and multiple examples to test. The opposite situation also happens where we have multiple test functions, all of which want the same input data.\nThe name that pytest uses for “data which are provided to test functions” is fixture since it fixes a set of data against which to test.\nWe’ll start with the example of the add_arrays function to explain the syntax but soon we’ll need to use an example which demonstates the benefits more.\nTo make things clearer, we’ll trim down the test file back to the basics. Just one test for add_arrays:\n\n\"\"\"\nThis module contains functions for manipulating and combining Python lists.\n\"\"\"\n\ndef add_arrays(x, y):\n    \"\"\"\n    This function adds together each element of the two passed lists.\n\n    Args:\n        x (list): The first list to add\n        y (list): The second list to add\n\n    Returns:\n        list: the pairwise sums of ``x`` and ``y``.\n\n    Examples:\n        &gt;&gt;&gt; add_arrays([1, 4, 5], [4, 3, 5])\n        [5, 7, 10]\n    \"\"\"\n\n    if len(x) != len(y):\n        raise ValueError(\"Both arrays must have the same length.\")\n\n    z = []\n    for x_, y_ in zip(x, y):\n        z.append(x_ + y_)\n\n    return z\n\nfrom arrays import add_arrays\n\ndef test_add_arrays():\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n    expect = [5, 7, 9]\n    \n    output = add_arrays(a, b)\n    \n    assert output == expect\nTo create our fixture we define a function which is decorated with the pytest.fixture decorator. Apart from that, all the function needs to do is return the data we want to provide to our tests, in this case, the two input lists:\nimport pytest\n\n@pytest.fixture\ndef pair_of_lists():\n    return [1, 2, 3], [4, 5, 6]\n\n\n\n\n\n\nDecorators\n\n\n\nPython decorators are functions that modify or enhance other functions without explicitly changing their source code. They take another function as an argument, add some functionality, and return the modified function. The key aspects are:\n\nThey are defined using the @decorator_name syntax placed above a function definition.\nDecorators wrap the original function, allowing you to execute code before and after the wrapped function.\nThey can modify the input arguments, return value, or behavior of the decorated function.\nMultiple decorators can be applied to a single function, creating a chain of modifications.\n\ndef uppercase_decorator(func):\n    def wrapper():\n        result = func()\n        return result.upper()\n    return wrapper\n\n@uppercase_decorator\ndef greet():\n    return \"hello, world!\"\n\nprint(greet())  # Output: HELLO, WORLD!\nThe above @uppercase_decorator syntax is equivalent to greet = uppercase_decorator(greet).\n\n\nTo make the test functions make use of the fixture, we use the name of the fixture (pair_of_lists) as a parameter of the test function, similar to how we did with parametrisation:\ndef test_add_arrays(pair_of_lists):\n    ...\nThe data are now available inside the function using that name and we can use it however we wish:\ndef test_add_arrays(pair_of_lists):\n    a, b = pair_of_lists\n    ...\nThis isn’t how functions and arguments usually work in Python. pytest is doing something magic here and is matching up the names of things which it knows are fixtures (due to the decorator) with the names of parameters to test functions, automatically running the fixture and passing in the data.\nNote that pair_of_lists here is not a test function. It does not contain any asserts and will not explicitly appear in the pytest output.\nPutting it all together, we end up with:\n\nimport pytest\n\nfrom arrays import add_arrays\n\n@pytest.fixture\ndef pair_of_lists():\n    return [1, 2, 3], [4, 5, 6]\n\ndef test_add_arrays(pair_of_lists):\n    a, b = pair_of_lists\n    expect = [5, 7, 9]\n    \n    output = add_arrays(a, b)\n    \n    assert output == expect\nWhen we run the test suite, pytest will automatically run the pair_of_lists function for any test that has it as an input and pass in the result.\nCOLUMNS=60 pytest -v test_arrays.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.12, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 -- /usr/bin/python3.8\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: anyio-3.3.4\ncollected 1 item                                           \u001b[0m\n\ntest_arrays.py::test_add_arrays \u001b[32mPASSED\u001b[0m\u001b[32m               [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 0.01s\u001b[0m\u001b[32m =====================\u001b[0m\n\nA different example\nIt might be hard to see the benefit of fixtures with this rather contrived example in which there aren’t repeated uses of the same input data. So lets take a look at a more sensible one where using a fixture makes sense.\nMake a new file called books.py which contains the following:\n\ndef word_count(text, word=''):\n    \"\"\"\n    Count the number of occurences of ``word`` in a string.\n    If ``word`` is not set, count all words.\n    \n    Args:\n        text (str): the text corpus to search through\n        word (str): the word to count instances of\n\n    Returns:\n        int: the count of ``word`` in ``text``\n    \"\"\"\n    if word:\n        count = 0\n        for text_word in text.split():\n            if text_word == word:\n                count += 1\n        return count\n    else:\n        return len(text.split())\nTo test this function we want a corpus of text to test it on. For the purposes of this example and to simulate a complex data input, we will download the contents of a particularly long novel from Project Gutenberg. Our test function uses urllib.request to download the text, converts it to a string and passes that to the word_count function.\nAt first we will simply check that the word “hat” appears 33 times in the book:\n\nimport urllib.request\n\nfrom books import word_count\n\ndef test_word_counts():\n    url = \"https://www.gutenberg.org/files/2600/2600-0.txt\"\n    book_text = urllib.request.urlopen(url).read().decode('utf-8')\n    assert word_count(book_text, \"hat\") == 33\nCOLUMNS=60 pytest -v test_books.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.12, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 -- /usr/bin/python3.8\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: anyio-3.3.4\ncollected 1 item                                           \u001b[0m\n\ntest_books.py::test_word_counts \u001b[32mPASSED\u001b[0m\u001b[32m               [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 1.93s\u001b[0m\u001b[32m =====================\u001b[0m\nThe test has passed and it took about two seconds. This is because it takes some time to download the file from the internet. For this example we want it to take some time as it helps demonstrate the point. In reality you will come across test data inputs which take some time (more than a few milliseconds) to create.\nThis creates a tension between wanting to have a large test suite which covers your code from lots of different angles and being able to run it very quickly and easily. An ideal test suite will run as quickly as possible as it will encourage you to run it more often. It’s a good idea to have at least a subset of your tests which run through in some number of seconds rather than hours.\nTwo seconds is not bad for this test but if we want to test against multiple examples, it could get slow. Let’s parametrise the test to add in a bunch more inputs:\n\nimport urllib.request\n\nimport pytest\n\nfrom books import word_count\n\n@pytest.mark.parametrize('word, count',  [\n    ('hat', 33),\n    ('freedom', 71),\n    ('electricity', 1),\n    ('testing', 3),\n    ('Prince', 1499),\n    ('internet', 0),\n    ('Russia', 71),\n    ('Pierre', 1260),\n    (None, 566334),\n])\ndef test_word_counts(word, count):\n    url = \"https://www.gutenberg.org/files/2600/2600-0.txt\"\n    book_text = urllib.request.urlopen(url).read().decode('utf-8')\n    assert word_count(book_text, word) == count\nCOLUMNS=60 pytest -v test_books.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.12, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 -- /usr/bin/python3.8\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: anyio-3.3.4\ncollected 9 items                                          \u001b[0m\n\ntest_books.py::test_word_counts[hat-33] \u001b[32mPASSED\u001b[0m\u001b[32m       [ 11%]\u001b[0m\ntest_books.py::test_word_counts[freedom-71] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 22%]\u001b[0m\ntest_books.py::test_word_counts[electricity-1] \u001b[32mPASSED\u001b[0m\u001b[32m [ 33%]\u001b[0m\ntest_books.py::test_word_counts[testing-3] \u001b[32mPASSED\u001b[0m\u001b[32m    [ 44%]\u001b[0m\ntest_books.py::test_word_counts[Prince-1499] \u001b[32mPASSED\u001b[0m\u001b[32m  [ 55%]\u001b[0m\ntest_books.py::test_word_counts[internet-0] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 66%]\u001b[0m\ntest_books.py::test_word_counts[Russia-71] \u001b[32mPASSED\u001b[0m\u001b[32m    [ 77%]\u001b[0m\ntest_books.py::test_word_counts[Pierre-1260] \u001b[32mPASSED\u001b[0m\u001b[32m  [ 88%]\u001b[0m\ntest_books.py::test_word_counts[None-566334] \u001b[32mPASSED\u001b[0m\u001b[32m  [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m9 passed\u001b[0m\u001b[32m in 22.76s\u001b[0m\u001b[32m ====================\u001b[0m\nYou see here that it took about nine times as long. This is because the file is downloaded afresh for every test example where really, it only needs to be downloaded once.\nLet’s move the slow setup into a fixture and give that as a parameter of the test function:\n\nimport urllib.request\n\nimport pytest\n\nfrom books import word_count\n\n@pytest.fixture()\ndef long_book():\n    url = \"https://www.gutenberg.org/files/2600/2600-0.txt\"\n    book_text = urllib.request.urlopen(url).read().decode('utf-8')\n    return book_text\n\n@pytest.mark.parametrize('word, count',  [\n    ('hat', 33),\n    ('freedom', 71),\n    ('electricity', 1),\n    ('testing', 3),\n    ('Prince', 1499),\n    ('internet', 0),\n    ('Russia', 71),\n    ('Pierre', 1260),\n    (None, 566334),\n])\ndef test_word_counts(long_book, word, count):\n    assert word_count(long_book, word) == count\nCOLUMNS=60 pytest -v test_books.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.12, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 -- /usr/bin/python3.8\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: anyio-3.3.4\ncollected 9 items                                          \u001b[0m\n\ntest_books.py::test_word_counts[hat-33] \u001b[32mPASSED\u001b[0m\u001b[32m       [ 11%]\u001b[0m\ntest_books.py::test_word_counts[freedom-71] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 22%]\u001b[0m\ntest_books.py::test_word_counts[electricity-1] \u001b[32mPASSED\u001b[0m\u001b[32m [ 33%]\u001b[0m\ntest_books.py::test_word_counts[testing-3] \u001b[32mPASSED\u001b[0m\u001b[32m    [ 44%]\u001b[0m\ntest_books.py::test_word_counts[Prince-1499] \u001b[32mPASSED\u001b[0m\u001b[32m  [ 55%]\u001b[0m\ntest_books.py::test_word_counts[internet-0] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 66%]\u001b[0m\ntest_books.py::test_word_counts[Russia-71] \u001b[32mPASSED\u001b[0m\u001b[32m    [ 77%]\u001b[0m\ntest_books.py::test_word_counts[Pierre-1260] \u001b[32mPASSED\u001b[0m\u001b[32m  [ 88%]\u001b[0m\ntest_books.py::test_word_counts[None-566334] \u001b[32mPASSED\u001b[0m\u001b[32m  [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m9 passed\u001b[0m\u001b[32m in 27.78s\u001b[0m\u001b[32m ====================\u001b[0m\nPerhaps surprisingly, it is still taking very long time!\nBy default a fixture will run once for every test function that uses it. In our case we only need it to run once for all the tests in the test session so we can pass in the scope parameter to pytest.fixture and set it to session:\n\nimport urllib.request\n\nimport pytest\n\nfrom books import word_count\n\n@pytest.fixture(scope=\"session\")\ndef long_book():\n    url = \"https://www.gutenberg.org/files/2600/2600-0.txt\"\n    book_text = urllib.request.urlopen(url).read().decode('utf-8')\n    return book_text\n\n@pytest.mark.parametrize('word, count',  [\n    ('hat', 33),\n    ('freedom', 71),\n    ('electricity', 1),\n    ('testing', 3),\n    ('Prince', 1499),\n    ('internet', 0),\n    ('Russia', 71),\n    ('Pierre', 1260),\n    (None, 566334),\n])\ndef test_word_counts(long_book, word, count):\n    assert word_count(long_book, word) == count\nCOLUMNS=60 pytest -v test_books.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.12, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 -- /usr/bin/python3.8\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: anyio-3.3.4\ncollected 9 items                                          \u001b[0m\n\ntest_books.py::test_word_counts[hat-33] \u001b[32mPASSED\u001b[0m\u001b[32m       [ 11%]\u001b[0m\ntest_books.py::test_word_counts[freedom-71] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 22%]\u001b[0m\ntest_books.py::test_word_counts[electricity-1] \u001b[32mPASSED\u001b[0m\u001b[32m [ 33%]\u001b[0m\ntest_books.py::test_word_counts[testing-3] \u001b[32mPASSED\u001b[0m\u001b[32m    [ 44%]\u001b[0m\ntest_books.py::test_word_counts[Prince-1499] \u001b[32mPASSED\u001b[0m\u001b[32m  [ 55%]\u001b[0m\ntest_books.py::test_word_counts[internet-0] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 66%]\u001b[0m\ntest_books.py::test_word_counts[Russia-71] \u001b[32mPASSED\u001b[0m\u001b[32m    [ 77%]\u001b[0m\ntest_books.py::test_word_counts[Pierre-1260] \u001b[32mPASSED\u001b[0m\u001b[32m  [ 88%]\u001b[0m\ntest_books.py::test_word_counts[None-566334] \u001b[32mPASSED\u001b[0m\u001b[32m  [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m9 passed\u001b[0m\u001b[32m in 3.39s\u001b[0m\u001b[32m =====================\u001b[0m\nNow it only takes about as long as a single test did since the slow part is only being done once.\n\n\n\n\n\n\nExercise\n\n\n\nAdd some more parameters to the test and check that it doesn’t take any longer to run",
    "crumbs": [
      "Input data for tests"
    ]
  },
  {
    "objectID": "pages/answer_simple_doc_message.html",
    "href": "pages/answer_simple_doc_message.html",
    "title": "Best Practices in Software Engineering",
    "section": "",
    "text": "The file index.rst should look like\n.. Arrays documentation master file, created by\n   sphinx-quickstart on Wed Oct 16 15:33:52 2019.\n   You can adapt this file completely to your liking, but it should at least\n   contain the root `toctree` directive.\n\nWelcome to Arrays's documentation!\n==================================\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\nThis documentation site is all about the arrays module and how to use it.\n\nIndices and tables\n==================\n\n* :ref:`genindex`\n* :ref:`modindex`\n* :ref:`search`\nand should create an output like:\n\n\n\nArrays documentation"
  },
  {
    "objectID": "pages/010-good-software-principles.html",
    "href": "pages/010-good-software-principles.html",
    "title": "Tenets of good software",
    "section": "",
    "text": "Taking a break from learning new syntax or technical tools to think about how we can write better code. There are numerous blogs, articles and books about these topics but I wanted to pick out a few that I think are particularly worthwhile.\n\nDon’t repeat yourself\nOne of the first and easiest to apply is that of avoiding repetition. This is often referred to as the DRY principle.\nThe most direct application of this is that of using functions. If you’re ever in the situation where you are copying and pasting code, it’s probably worth stopping and thinking “should I move this into a function?”.\nThe advantage of the DRY principle is that by avoiding duplication you make maintenance easier. If you want to update, change or fix something you only need to do it in one place.\n\n\nMake your code easy to use correctly and hard to use incorrectly\nThis is a principle that was coined by Scott Meyers in 2004. The idea being that if you are writing code which will be used by others (functions, classes etc.) or writing user-interfaces (website, apps etc.) then you should endeavour to make the correct use of your product the “easy path”.\nAs an example, let’s look at a function which calculated the distance in kilometres between a given latitude/longitude pair and Bristol:\nfrom math import sin, cos, sqrt, atan2, radians\n\ndef distance_from_bristol(lon, lat):\n    \"\"\"\n    Given a longitude and latitude in degrees,\n    return the distance in km from Bristol.\n    \"\"\"\n    lon, lat = radians(lon), radians(lat)\n    bristol_lat = radians(51.4539886)\n    bristol_lon = radians(-2.6068184)\n    dlon = lon - bristol_lon\n    dlat = lat - bristol_lat\n    a = sin(dlat / 2)**2 + cos(bristol_lat) * cos(lat) * sin(dlon / 2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    return 6373.0 * c\nWhen we come to use this function, we call it by passing the two values:\nlat_london = 51.5006895\nlon_london = -0.1245838\n\ndistance_from_bristol(lat_london, lon_london)\n7638.924775713775\nThat number is far too big! What happened?\nThe problem here is that the function expected the arguments to be passed in a longitude first and the latitude but we passed them the other way around. This function is easy to use incorrectly.\nTo help solve this, Python has a feature where you can specify that certain arguments must be passed in as named arguments. This is done by setting a literal * as a parameter and then all following parameters must only be passed by name:\ndef distance_from_bristol(*, lon, lat):  #  ← the only line that has changed\n    \"\"\"\n    Given a longitude and latitude in degrees,\n    return the distance in km from Bristol.\n    \"\"\"\n    lon, lat = radians(lon), radians(lat)\n    bristol_lat = radians(51.4539886)\n    bristol_lon = radians(-2.6068184)\n    dlon = lon - bristol_lon\n    dlat = lat - bristol_lat\n    a = sin(dlat / 2)**2 + cos(bristol_lat) * cos(lat) * sin(dlon / 2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    return 6373.0 * c\nNow when we try to call the function without specifying which argument is which, we get an error:\ndistance_from_bristol(lat_london, lon_london)\n---------------------------------------------------------------------------\n\nTypeError                                 Traceback (most recent call last)\n\n&lt;ipython-input-4-343c08b29905&gt; in &lt;module&gt;\n----&gt; 1 distance_from_bristol(lat_london, lon_london)\n\n\nTypeError: distance_from_bristol() takes 0 positional arguments but 2 were given\nOnce we are explicit, it works correctly:\ndistance_from_bristol(lat=lat_london, lon=lon_london)\n172.03101346881488\nIt is now harder to use incorrectly.\nThere’s still the issue that it’s very easy to pass in the latitude and longitude in the wrong units. A potential solution to this would be to create a Point class which encode within it whether the units are degree or radians and require users of that class to specify then putting in values or removing them.\n\n\nThe Zen of Python\nPython has a document, called The Zen of Python, which describes what it considers the core principles for writing good Python code. It is available as Python Enhancement Proposal 20 and is also available by importing the special this module.\nIt’s worth having a read through as almost all of these ideas apply to programming in general.\nimport this\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\nOf particular note are:\nReadability counts. When writing code, don’t just think about how it will be interpreted by the computer, also consider your fellow human. Code will be read many more time than it is written so optimise for understandability.\nErrors should never pass silently. This is the logic behind Python’s use of exceptions. You can’t ignore an error unless you explicitly decide to. This is in contrast to common techniques in use in languages like C where a function might return a 0 if it was successful or a 1 otherwise and it would be up to the person calling the function to remember to check the value themselves.\nThere should be one — and preferably only one — obvious way to do it. This goes hand-in-hand with the idea of making your code easy to use correctly and hard to use incorrectly. Provide a simple and consistent interface to your users, and don’t display unnecessary complexity.\nTo explain the “unless you’re Dutch” comment, the Zen of Python was written by Tim Peters in the early days of Python and this is intended as a friendly jab at the creator of Python Guido van Rossum who is Dutch.\nThere’s a lot of good advice in there and I recommend coming back and giving it a read every now and again. Despite it being over 20 years old, it’s still completely relevant.\n\n\nTestable code is better code\nThe one rule that I’ve found to be the most useful when deciding what is “good code” is the question “how easy is this to test?”. If there’s one thing to take away from this course, I’d say it should be this.\nYou will find that in the process of thinking about how to make your code more easily testable you’ll make it more modular, composable and with better-defined interfaces. All of which make it cleaner, easier to understand and more maintainable.\nTesting therefore has the double benefit of both giving confidence that your code is correct and making the code better along the way.",
    "crumbs": [
      "Tenets of good software"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Welcome to this short course which will introduce you to some techniques and processes which are essential if you are going to be developing professional-quality software.\nFor this course we will be focusing on three main topics:\n\ndocumentation\ntesting\nlicensing\n\nand discussing why they’re important and how to integrate them into your code. To discover these concepts we will be exploring then in Python but the ideas behind what we’re doing here apply to all programming languages. You can do documentation and testing in C, C++, R, Fortran, Julia, Go and Rust but each will have their own tools and techniques. Languages which make going these things easy are good languages for doing software development in.\nFor the purpose of this course we will be using a free tool called JupyterLab which provides you with a local editor and Python terminal in your web browser. Setting up instructions can be found here.\n\nIntended learning outcomes\nBy the end of this course, you will:\n\nKnow how to document your Python functions and modules\nWrite test functions and automate them\nKnow how to do testing with multiple data\nUnderstand the principles of licensing code\n\n\n\nHow to read this documentation\nIn this documentation, any time that we are seeing a small snippet of Python code, we’ll see it written in a grey box like the following:\nprint(\"Hello, Python\")\nIf the commands are executed by the machine we will see the output of them below enclosed on a vertical purple line:\n\nprint(\"Hello, Python!\")\n\nHello, Python!\n\n\nBy contrast, you will see larger peces of code as scripts with a given name, e.g. script.py, in a code block with darker header:\n\n\nscript.py\n\ngreeting = \"Hello\"\nname = input(\"What is your name? \")\nprint(greeting, name)\n\nWe may ask you to run a script using the Command Prompt (Windows) or Terminal (Mac and Linux). We will show you what commands to run and will look like this:\n\n\nTerminal/Command Prompt\n\npython script.py\n\nPlease note that sometimes we will skip showing the execution of scripts on the Terminal/Command Prompt box, but we will assume you to run the script on your.\nIn some cases we will introduce general programming concepts and structures using pseudocode, a high-level, easy-to-read syntax close to natural language. This should not be confused with Python code and cannot be executed on your machine, but it is useful to describe how your code should behave. Here there is an example:\nFOR EACH sample IN my_study\n    IF (sample.value &gt; 100)\n        DO SOMETHING\n    OTHERWISE\n        DO SOMETHING ELSE\nThere are some exercises along this course, and it is important you try to answer them yourself to understand how Python works. Exercises are shown in blue boxes followed by a yellow box that contains the answer of each exercise. We recommend you to try to answer each exercise yourself before looking at the solution.\n\n\n\n\n\n\nExercise\n\n\n\nThis is an exercise. You will need to click in the below box to see the answer.\n\n\n\n\n\n\n\n\nAnswer (click to open)\n\n\n\n\n\nThis is the answer.\n\n\n\nLast, we will highlight important points using green boxes like this one:\n\n\n\n\n\n\nKey points\n\n\n\nThese are important concepts and technical notes.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "pages/answer_final_morse_error.html",
    "href": "pages/answer_final_morse_error.html",
    "title": "Best Practices in Software Engineering",
    "section": "",
    "text": "# A lookup dictionary which, given a letter will return the morse code equivalent\n_letter_to_morse = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n                   'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n                   'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n                   'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n                   '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n                   '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.',\n                   ' ':'/'}\n\n# This will create a dictionary that can go from the morse back to the letter\n_morse_to_letter = {}\nfor letter in _letter_to_morse:\n    morse = _letter_to_morse[letter]\n    _morse_to_letter[morse] = letter\n\n\ndef encode(message):\n    \"\"\"\n    Encode a message from English to Morse Code\n    \n    Args:\n        message (str): the English message to encode\n    \n    Returns:\n        str: The encoded message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\"Help us\")\n        '.... . .-.. .--. / ..- ...'\n    \"\"\"\n    morse = []\n\n    for letter in message:\n        letter = letter.lower()\n        \n        if letter not in _letter_to_morse:\n            raise ValueError(f\"Cannot encode \\\"{message}\\\". Character \\\"{letter}\\\" not in Morse dictionary\")\n        \n        morse.append(_letter_to_morse[letter])\n\n    # We need to join together Morse code letters with spaces\n    morse_message = \" \".join(morse)\n    \n    return morse_message\n\n\ndef decode(message):\n    \"\"\"\n    Decode a message from Morse Code to English\n    \n    Args:\n        message (str): the Morse Code message to decode\n    \n    Returns:\n        str: The decoded English message\n    \n    Examples:\n        &gt;&gt;&gt; decode(\".... . .-.. .--. / ..- ...\")\n        'help us'\n    \"\"\"\n    english = []\n\n    # Now we cannot read by letter. We know that morse letters are\n    # separated by a space, so we split the morse string by spaces\n    morse_letters = message.split(\" \")\n\n    for letter in morse_letters:\n        english.append(_morse_to_letter[letter])\n\n    # Rejoin, but now we don't need to add any spaces\n    english_message = \"\".join(english)\n    \n    return english_message\n\nimport pytest\n\nfrom morse import encode, decode\n\n@pytest.mark.parametrize(\"message, output\", [\n    (\"SOS\", \"... --- ...\"),\n    (\"help\", \".... . .-.. .--.\"),\n    (\"\", \"\"),\n    (\" \", \"/\"),\n])\ndef test_encode(message, output):\n    assert encode(message) == output\n\n@pytest.mark.parametrize(\"message, output\", [\n    (\"... --- ...\", \"sos\"),\n    (\".... . .-.. .--.\", \"help\"),\n    (\"/\", \" \"),\n])\ndef test_decode(message, output):\n    assert decode(message) == output\n\ndef test_error():  # New test\n    with pytest.raises(ValueError):\n        encode(\"Don't forget to save us\")\n\n@pytest.mark.parametrize(\"message\", [\n    \"It's sinking\",\n    \"Titanic & Olympic\",\n    \"This boat is expensive £££\",\n    \"Help!\",\n])\ndef test_errors(message):  # New test\n    with pytest.raises(ValueError):\n        encode(message)\nOverwriting test_morse.py\nCOLUMNS=60 pytest -v --doctest-modules morse.py test_morse.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.2, py-1.9.0, pluggy-0.13.1 -- /home/matt/projects/courses/software_engineering_best_practices/venv/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: nbval-0.9.6\ncollected 14 items                                         \u001b[0m\n\nmorse.py::morse.decode \u001b[32mPASSED\u001b[0m\u001b[32m                        [  7%]\u001b[0m\nmorse.py::morse.encode \u001b[32mPASSED\u001b[0m\u001b[32m                        [ 14%]\u001b[0m\ntest_morse.py::test_encode[SOS-... --- ...] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 21%]\u001b[0m\ntest_morse.py::test_encode[help-.... . .-.. .--.] \u001b[32mPASSED\u001b[0m\u001b[32m [ 28%]\u001b[0m\ntest_morse.py::test_encode[-] \u001b[32mPASSED\u001b[0m\u001b[32m                 [ 35%]\u001b[0m\ntest_morse.py::test_encode[ -/] \u001b[32mPASSED\u001b[0m\u001b[32m               [ 42%]\u001b[0m\ntest_morse.py::test_decode[... --- ...-sos] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 50%]\u001b[0m\ntest_morse.py::test_decode[.... . .-.. .--.-help] \u001b[32mPASSED\u001b[0m\u001b[32m [ 57%]\u001b[0m\ntest_morse.py::test_decode[/- ] \u001b[32mPASSED\u001b[0m\u001b[32m               [ 64%]\u001b[0m\ntest_morse.py::test_error \u001b[32mPASSED\u001b[0m\u001b[32m                     [ 71%]\u001b[0m\ntest_morse.py::test_errors[It's sinking] \u001b[32mPASSED\u001b[0m\u001b[32m      [ 78%]\u001b[0m\ntest_morse.py::test_errors[Titanic & Olympic] \u001b[32mPASSED\u001b[0m\u001b[32m [ 85%]\u001b[0m\ntest_morse.py::test_errors[This boat is expensive \\xa3\\xa3\\xa3] \u001b[32mPASSED\u001b[0m\u001b[32m [ 92%]\u001b[0m\ntest_morse.py::test_errors[Help!] \u001b[32mPASSED\u001b[0m\u001b[32m             [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m14 passed\u001b[0m\u001b[32m in 0.03s\u001b[0m\u001b[32m ====================\u001b[0m"
  },
  {
    "objectID": "pages/answer_final_rot13_fix.html",
    "href": "pages/answer_final_rot13_fix.html",
    "title": "Best Practices in Software Engineering",
    "section": "",
    "text": "import string\n\n_lower_cipher = string.ascii_lowercase[13:] + string.ascii_lowercase[:13]\n_upper_cipher = string.ascii_uppercase[13:] + string.ascii_uppercase[:13]\n\ndef encode(message):\n    \"\"\"\n    Encode a message from English to ROT13\n    \n    Args:\n        message (str): the English message to encode\n    \n    Returns:\n        str: The encoded message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\"Secretmessage\")\n        'Frpergzrffntr'\n    \"\"\"\n    output = []\n    for letter in message:\n        if letter in string.ascii_lowercase:\n            i = string.ascii_lowercase.find(letter)\n            output.append(_lower_cipher[i])\n        elif letter in string.ascii_uppercase:\n            i = string.ascii_uppercase.find(letter)\n            output.append(_upper_cipher[i])\n        else:  # Add this else statement\n            raise ValueError(f\"Cannot encode \\\"{message}\\\". Character \\\"{letter}\\\" not valid\")\n    \n    return \"\".join(output)\n\n\ndef decode(message):\n    \"\"\"\n    Encode a message from ROT13 to English\n    \n    Args:\n        message (str): the ROT13 message to encode\n    \n    Returns:\n        str: The decoded message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\"Frpergzrffntr\")\n        'Secretmessage'\n    \"\"\"\n    output = []\n    for letter in message:\n        if letter in _lower_cipher:\n            i = _lower_cipher.find(letter)\n            output.append(string.ascii_lowercase[i])  # ascii_uppercase → ascii_lowercase\n        elif letter in _upper_cipher:\n            i = _upper_cipher.find(letter)\n            output.append(string.ascii_uppercase[i])\n        else:  # Add this else statement\n            raise ValueError(f\"Cannot decode \\\"{message}\\\". Character \\\"{letter}\\\" not valid\")\n    \n    return \"\".join(output)\n\n    # An alternate \"clever\" solution is to exploit the fact that rot13 is its own inverse\n    # and simply call the encode function again. The entirety of this function would then\n    # just become:\n    #\n    # return encode(message)\n\nimport pytest\n\nfrom rot13 import encode, decode\n\n@pytest.mark.parametrize(\"message, expected\", [\n    (\"SECRET\", \"FRPERG\"),\n    (\"secret\", \"frperg\"),\n])\ndef test_encode(message, expected):\n    assert encode(message) == expected\n\n@pytest.mark.parametrize(\"message, expected\", [\n    (\"FRPERG\", \"SECRET\"),\n    (\"frperg\", \"secret\"),\n])\ndef test_decode(message, expected):\n    assert decode(message) == expected\n\ndef test_encode_spaces_error():\n    with pytest.raises(ValueError):\n        encode(\"Secret message for you\")\nCOLUMNS=60 pytest -v --doctest-modules morse.py rot13.py test_morse.py test_rot13.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 21 items                                         \u001b[0m\n\nmorse.py::morse.decode \u001b[32mPASSED\u001b[0m\u001b[32m                        [  4%]\u001b[0m\nmorse.py::morse.encode \u001b[32mPASSED\u001b[0m\u001b[32m                        [  9%]\u001b[0m\nrot13.py::rot13.decode \u001b[32mPASSED\u001b[0m\u001b[32m                        [ 14%]\u001b[0m\nrot13.py::rot13.encode \u001b[32mPASSED\u001b[0m\u001b[32m                        [ 19%]\u001b[0m\ntest_morse.py::test_encode[SOS-... --- ...] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 23%]\u001b[0m\ntest_morse.py::test_encode[help-.... . .-.. .--.] \u001b[32mPASSED\u001b[0m\u001b[32m [ 28%]\u001b[0m\ntest_morse.py::test_encode[-] \u001b[32mPASSED\u001b[0m\u001b[32m                 [ 33%]\u001b[0m\ntest_morse.py::test_encode[ -/] \u001b[32mPASSED\u001b[0m\u001b[32m               [ 38%]\u001b[0m\ntest_morse.py::test_decode[... --- ...-sos] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 42%]\u001b[0m\ntest_morse.py::test_decode[.... . .-.. .--.-help] \u001b[32mPASSED\u001b[0m\u001b[32m [ 47%]\u001b[0m\ntest_morse.py::test_decode[/- ] \u001b[32mPASSED\u001b[0m\u001b[32m               [ 52%]\u001b[0m\ntest_morse.py::test_error \u001b[32mPASSED\u001b[0m\u001b[32m                     [ 57%]\u001b[0m\ntest_morse.py::test_errors[It's sinking] \u001b[32mPASSED\u001b[0m\u001b[32m      [ 61%]\u001b[0m\ntest_morse.py::test_errors[Titanic & Olympic] \u001b[32mPASSED\u001b[0m\u001b[32m [ 66%]\u001b[0m\ntest_morse.py::test_errors[This boat is expensive \\xa3\\xa3\\xa3] \u001b[32mPASSED\u001b[0m\u001b[32m [ 71%]\u001b[0m\ntest_morse.py::test_errors[Help!] \u001b[32mPASSED\u001b[0m\u001b[32m             [ 76%]\u001b[0m\ntest_rot13.py::test_encode[SECRET-FRPERG] \u001b[32mPASSED\u001b[0m\u001b[32m     [ 80%]\u001b[0m\ntest_rot13.py::test_encode[secret-frperg] \u001b[32mPASSED\u001b[0m\u001b[32m     [ 85%]\u001b[0m\ntest_rot13.py::test_decode[FRPERG-SECRET] \u001b[32mPASSED\u001b[0m\u001b[32m     [ 90%]\u001b[0m\ntest_rot13.py::test_decode[frperg-secret] \u001b[32mPASSED\u001b[0m\u001b[32m     [ 95%]\u001b[0m\ntest_rot13.py::test_encode_spaces_error \u001b[32mPASSED\u001b[0m\u001b[32m       [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m21 passed\u001b[0m\u001b[32m in 0.06s\u001b[0m\u001b[32m ====================\u001b[0m"
  },
  {
    "objectID": "pages/answer_final_morse_test.html",
    "href": "pages/answer_final_morse_test.html",
    "title": "Best Practices in Software Engineering",
    "section": "",
    "text": "# A lookup dictionary which, given a letter will return the morse code equivalent\n_letter_to_morse = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n                   'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n                   'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n                   'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n                   '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n                   '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.',\n                   ' ':'/'}\n\n# This will create a dictionary that can go from the morse back to the letter\n_morse_to_letter = {}\nfor letter in _letter_to_morse:\n    morse = _letter_to_morse[letter]\n    _morse_to_letter[morse] = letter\n\n\ndef encode(message):\n    \"\"\"\n    Encode a message from English to Morse Code\n    \n    Args:\n        message (str): the English message to encode\n    \n    Returns:\n        str: The encoded message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\"Help us\")\n        '.... . .-.. .--. / ..- ...'\n    \"\"\"\n    morse = []\n\n    for letter in message:\n        letter = letter.lower()\n        morse.append(_letter_to_morse[letter])\n\n    # We need to join together Morse code letters with spaces\n    morse_message = \" \".join(morse)\n    \n    return morse_message\n\n\ndef decode(message):\n    \"\"\"\n    Decode a message from Morse Code to English\n    \n    Args:\n        message (str): the Morse Code message to decode\n    \n    Returns:\n        str: The decoded English message\n    \n    Examples:\n        &gt;&gt;&gt; decode(\".... . .-.. .--. / ..- ...\")\n        'help us'\n    \"\"\"\n    english = []\n\n    # Now we cannot read by letter. We know that morse letters are\n    # separated by a space, so we split the morse string by spaces\n    morse_letters = message.split(\" \")\n\n    for letter in morse_letters:\n        english.append(_morse_to_letter[letter])\n\n    # Rejoin, but now we don't need to add any spaces\n    english_message = \"\".join(english)\n    \n    return english_message\nOverwriting morse.py\n\nimport pytest\n\nfrom morse import encode, decode\n\n@pytest.mark.parametrize(\"message, output\", [\n    (\"SOS\", \"... --- ...\"),\n    (\"help\", \".... . .-.. .--.\"),\n    (\"\", \"\"),\n    (\" \", \"/\"),\n])\ndef test_encode(message, output):\n    assert encode(message) == output\n\n@pytest.mark.parametrize(\"message, output\", [\n    (\"... --- ...\", \"sos\"),\n    (\".... . .-.. .--.\", \"help\"),\n    (\"/\", \" \"),\n])\ndef test_decode(message, output):\n    assert decode(message) == output\nOverwriting test_morse.py\nCOLUMNS=60 pytest -v --doctest-modules morse.py test_morse.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 9 items                                          \u001b[0m\n\nmorse.py::morse.decode \u001b[32mPASSED\u001b[0m\u001b[32m                        [ 11%]\u001b[0m\nmorse.py::morse.encode \u001b[32mPASSED\u001b[0m\u001b[32m                        [ 22%]\u001b[0m\ntest_morse.py::test_encode[SOS-... --- ...] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 33%]\u001b[0m\ntest_morse.py::test_encode[help-.... . .-.. .--.] \u001b[32mPASSED\u001b[0m\u001b[32m [ 44%]\u001b[0m\ntest_morse.py::test_encode[-] \u001b[32mPASSED\u001b[0m\u001b[32m                 [ 55%]\u001b[0m\ntest_morse.py::test_encode[ -/] \u001b[32mPASSED\u001b[0m\u001b[32m               [ 66%]\u001b[0m\ntest_morse.py::test_decode[... --- ...-sos] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 77%]\u001b[0m\ntest_morse.py::test_decode[.... . .-.. .--.-help] \u001b[32mPASSED\u001b[0m\u001b[32m [ 88%]\u001b[0m\ntest_morse.py::test_decode[/- ] \u001b[32mPASSED\u001b[0m\u001b[32m               [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m9 passed\u001b[0m\u001b[32m in 0.04s\u001b[0m\u001b[32m =====================\u001b[0m"
  },
  {
    "objectID": "pages/980-summary.html",
    "href": "pages/980-summary.html",
    "title": "Summary",
    "section": "",
    "text": "That’s all we have for this workshop. By now you should have a better understanding of how you can make your code more maintanable, reusable and easy to share. In this workshow we have covered:\n\nDocumentation\n\nWhat should be documented\nHow to make your documentation accessible as HTML\n\nLicensing\nTesting\n\nHow to test your code\nParametrising your tests\nProviding test data in fixtures\n\n\nI consider these three topics to be essential for effective software development along with version control through a tool such as Git.\nYou don’t need to have tested very single corner of your code and you don’t need to have perfect docstrings for your functions but just having something is better than having nothing. These techniques are not about being perfect but simply about being better.\nThings to read up on or attend courses about next would likely be:\n\nVersion control using Git\n\nincluding collaborative development with a platform like GitHub or GitLab using Pull Requests\n\nAutomated testing, also referred to as continuous integration or continuous testing\nCode quality checks (such as pycodestyle, Pylint and MyPy in Python)\nPackaging your software for easy distribution (e.g. using PyPI for Python)\n\nFor information on some of these topics, a good source is The Hitchhiker’s Guide to Python, particularly the section on Writing Great Python Code.",
    "crumbs": [
      "Summary"
    ]
  },
  {
    "objectID": "pages/appendix_sphinx.html",
    "href": "pages/appendix_sphinx.html",
    "title": "Best Practices in Software Engineering",
    "section": "",
    "text": "Providing documentation for your functions inside the Python Console is a useful thing to do but it’s expected of most publicly published projects to also have a web-browsable version as well. There is a tool for Python called Sphinx which does exactly that.\nMake sure Sphinx is installed. Test in the Terminal that sphinx-build exists by running it and checking that it returns the message:\nusage: sphinx-build [OPTIONS] SOURCEDIR OUTPUTDIR [FILENAMES...]\nsphinx-build: error: the following arguments are required: sourcedir, outputdir, filenames\nIf it is not installed then either: - install it into the base environment through Anaconda Navigator - or create a new environment, install both jupyterlab and sphinx and then restart JupyterLab in that environment.\nOpen up the terminal and make sure that you are in the correct directory. You can check this by running ls if you are on Linux or MacOS or dir if you are running Windows. You should see arrays.py listed in the output.\nWe are now going to create a set of Sphinx configuration files. Sphinx provides a tool called sphinx-quickstart for this purpose which will ask you a few questions and create all the files it needs. In the Terminal, type:\nsphinx-quickstart\nand answer the questions it asks in the following way:\n\nn to Separate source and build directories\nSet the project name to Arrays\nEnter your name as the Author name\nJust press enter for Project release\nJust press enter for Project language\n\nAfter that it should return you to the Terminal prompt.\nNow that we have the configuration for Sphinx set up, run make html which will go ahead and generate the documentation and create some HTML files on your computer. To find out where they went, run the following in the Python Console:\nimport os\nprint(f\"file://{os.getcwd()}/_build/html/index.html\")\nThat will print out something like file:///home/matt/bestpractices/_build/html/index.html. Copy and paste that into the URL bar in your web browser and it should bring up the documentation. It should look like:\n\n\n\nArrays documentation\n\n\n\n\n\n\n\n\nExercise\n\n\n\nAdd some text (it doesn’t matter too much what you write) between the toctree block and Indices and tables in index.rst. Make sure that it is not indented at all. Regenerate the documentation pages with make html and refresh your web browser. You should see the text appear.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe file index.rst should look like\n.. Arrays documentation master file, created by\n   sphinx-quickstart on Wed Oct 16 15:33:52 2019.\n   You can adapt this file completely to your liking, but it should at least\n   contain the root `toctree` directive.\n\nWelcome to Arrays's documentation!\n==================================\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\nThis documentation site is all about the arrays module and how to use it.\n\nIndices and tables\n==================\n\n* :ref:`genindex`\n* :ref:`modindex`\n* :ref:`search`\nand should create an output like:\n\n\n\nArrays documentation\n\n\n\n\n\n\n\nIn order for our function and module documentation to show up in the HTML pages we need to make a few tweaks to the Sphinx configuration.\nFirst we need to enable the autodoc extension so that Sphinx can create documentation pages from Python source code and the napoleon extension so that it understands the Google-style docstrings. Open conf.py (it’s a normal Python file) and find the extensions variable. It will be defined to be an empty list. Edit it so that it reads:\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.napoleon',\n]\nThe other change we need to make in conf.py is is to allow Sphinx to import our arrays module. To allow this it needs to have the current directory in its search path. Find on lines 13, 14, and 15 the lines that read:\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath('.'))\nand uncomment them so that they look like:\nimport os\nimport sys\nsys.path.insert(0, os.path.abspath('.'))\nThis is all the configuration changes we need to make. We’re now ready to tell Sphinx about our module. To do this we will put some special code in a file called arrays.rst whcih Sphinx will interpret to find our source code and documentation.\nCreate a new files called arrays.rst and put the following:\narrays module\n=============\n\n.. automodule:: arrays\n   :members:\n   :undoc-members:\n   :show-inheritance:\nThen edit the toctree directive in index.rst to look like:\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n   \n   arrays\nbeing careful to check that the indentation is correct and lines up.\nRun make html once more and refresh the documentation HTML page. On the main page, click “arrays module”. This will take you to the page with the documentation. It should look like:\n\n\n\nArrays documentation\n\n\nYou’ll see here that the module docstring is shown at the top, followed by the documentation for the function. It’s formatted the parameters and return types nicely and has even highlighted the example as Python code.\n\n\n\n\n\n\nExercise\n\n\n\nTry changing the theme to one from\nhttps://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes\n\n\nSphinx is by far the most commonly used documentation tool for Python projects. It’s even used by the official Python documentation. If you have your Python project hosted at a publicly visible Git hosting site like GitHub, GitLab or Bitbucket, there is a free service called Read The Docs which can build and host your pages for you.\nWhen using Git or any other version control software, you should make sure you check in your documentation sources alongside your code. For Sphinx, make sure you add conf.py, any rst files you create manually and the “make” files. Do not commit to Git any HTML output from running Sphinx."
  },
  {
    "objectID": "pages/appendix_sphinx.html#appendix-generating-documentation-web-pages",
    "href": "pages/appendix_sphinx.html#appendix-generating-documentation-web-pages",
    "title": "Best Practices in Software Engineering",
    "section": "",
    "text": "Providing documentation for your functions inside the Python Console is a useful thing to do but it’s expected of most publicly published projects to also have a web-browsable version as well. There is a tool for Python called Sphinx which does exactly that.\nMake sure Sphinx is installed. Test in the Terminal that sphinx-build exists by running it and checking that it returns the message:\nusage: sphinx-build [OPTIONS] SOURCEDIR OUTPUTDIR [FILENAMES...]\nsphinx-build: error: the following arguments are required: sourcedir, outputdir, filenames\nIf it is not installed then either: - install it into the base environment through Anaconda Navigator - or create a new environment, install both jupyterlab and sphinx and then restart JupyterLab in that environment.\nOpen up the terminal and make sure that you are in the correct directory. You can check this by running ls if you are on Linux or MacOS or dir if you are running Windows. You should see arrays.py listed in the output.\nWe are now going to create a set of Sphinx configuration files. Sphinx provides a tool called sphinx-quickstart for this purpose which will ask you a few questions and create all the files it needs. In the Terminal, type:\nsphinx-quickstart\nand answer the questions it asks in the following way:\n\nn to Separate source and build directories\nSet the project name to Arrays\nEnter your name as the Author name\nJust press enter for Project release\nJust press enter for Project language\n\nAfter that it should return you to the Terminal prompt.\nNow that we have the configuration for Sphinx set up, run make html which will go ahead and generate the documentation and create some HTML files on your computer. To find out where they went, run the following in the Python Console:\nimport os\nprint(f\"file://{os.getcwd()}/_build/html/index.html\")\nThat will print out something like file:///home/matt/bestpractices/_build/html/index.html. Copy and paste that into the URL bar in your web browser and it should bring up the documentation. It should look like:\n\n\n\nArrays documentation\n\n\n\n\n\n\n\n\nExercise\n\n\n\nAdd some text (it doesn’t matter too much what you write) between the toctree block and Indices and tables in index.rst. Make sure that it is not indented at all. Regenerate the documentation pages with make html and refresh your web browser. You should see the text appear.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe file index.rst should look like\n.. Arrays documentation master file, created by\n   sphinx-quickstart on Wed Oct 16 15:33:52 2019.\n   You can adapt this file completely to your liking, but it should at least\n   contain the root `toctree` directive.\n\nWelcome to Arrays's documentation!\n==================================\n\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n\nThis documentation site is all about the arrays module and how to use it.\n\nIndices and tables\n==================\n\n* :ref:`genindex`\n* :ref:`modindex`\n* :ref:`search`\nand should create an output like:\n\n\n\nArrays documentation\n\n\n\n\n\n\n\nIn order for our function and module documentation to show up in the HTML pages we need to make a few tweaks to the Sphinx configuration.\nFirst we need to enable the autodoc extension so that Sphinx can create documentation pages from Python source code and the napoleon extension so that it understands the Google-style docstrings. Open conf.py (it’s a normal Python file) and find the extensions variable. It will be defined to be an empty list. Edit it so that it reads:\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.napoleon',\n]\nThe other change we need to make in conf.py is is to allow Sphinx to import our arrays module. To allow this it needs to have the current directory in its search path. Find on lines 13, 14, and 15 the lines that read:\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath('.'))\nand uncomment them so that they look like:\nimport os\nimport sys\nsys.path.insert(0, os.path.abspath('.'))\nThis is all the configuration changes we need to make. We’re now ready to tell Sphinx about our module. To do this we will put some special code in a file called arrays.rst whcih Sphinx will interpret to find our source code and documentation.\nCreate a new files called arrays.rst and put the following:\narrays module\n=============\n\n.. automodule:: arrays\n   :members:\n   :undoc-members:\n   :show-inheritance:\nThen edit the toctree directive in index.rst to look like:\n.. toctree::\n   :maxdepth: 2\n   :caption: Contents:\n   \n   arrays\nbeing careful to check that the indentation is correct and lines up.\nRun make html once more and refresh the documentation HTML page. On the main page, click “arrays module”. This will take you to the page with the documentation. It should look like:\n\n\n\nArrays documentation\n\n\nYou’ll see here that the module docstring is shown at the top, followed by the documentation for the function. It’s formatted the parameters and return types nicely and has even highlighted the example as Python code.\n\n\n\n\n\n\nExercise\n\n\n\nTry changing the theme to one from\nhttps://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes\n\n\nSphinx is by far the most commonly used documentation tool for Python projects. It’s even used by the official Python documentation. If you have your Python project hosted at a publicly visible Git hosting site like GitHub, GitLab or Bitbucket, there is a free service called Read The Docs which can build and host your pages for you.\nWhen using Git or any other version control software, you should make sure you check in your documentation sources alongside your code. For Sphinx, make sure you add conf.py, any rst files you create manually and the “make” files. Do not commit to Git any HTML output from running Sphinx."
  },
  {
    "objectID": "pages/answer_final_rot13_roundtrip.html",
    "href": "pages/answer_final_rot13_roundtrip.html",
    "title": "Best Practices in Software Engineering",
    "section": "",
    "text": "# A lookup dictionary which, given a letter will return the morse code equivalent\n_letter_to_morse = {'a':'.-', 'b':'-...', 'c':'-.-.', 'd':'-..', 'e':'.', 'f':'..-.', \n                   'g':'--.', 'h':'....', 'i':'..', 'j':'.---', 'k':'-.-', 'l':'.-..', 'm':'--', \n                   'n':'-.', 'o':'---', 'p':'.--.', 'q':'--.-', 'r':'.-.', 's':'...', 't':'-',\n                   'u':'..-', 'v':'...-', 'w':'.--', 'x':'-..-', 'y':'-.--', 'z':'--..',\n                   '0':'-----', '1':'.----', '2':'..---', '3':'...--', '4':'....-',\n                   '5':'.....', '6':'-....', '7':'--...', '8':'---..', '9':'----.',\n                   ' ':'/'}\n\n# This will create a dictionary that can go from the morse back to the letter\n_morse_to_letter = {}\nfor letter in _letter_to_morse:\n    morse = _letter_to_morse[letter]\n    _morse_to_letter[morse] = letter\n\n\ndef encode(message):\n    \"\"\"\n    Encode a message from English to Morse Code\n    \n    Args:\n        message (str): the English message to encode\n    \n    Returns:\n        str: The encoded message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\"Help us\")\n        '.... . .-.. .--. / ..- ...'\n    \"\"\"\n    morse = []\n\n    for letter in message:\n        letter = letter.lower()\n        \n        if letter not in _letter_to_morse:\n            raise ValueError(f\"Cannot encode \\\"{message}\\\". Character \\\"{letter}\\\" not in Morse dictionary\")\n        \n        morse.append(_letter_to_morse[letter])\n\n    # We need to join together Morse code letters with spaces\n    morse_message = \" \".join(morse)\n    \n    return morse_message\n\n\ndef decode(message):\n    \"\"\"\n    Decode a message from Morse Code to English\n    \n    Args:\n        message (str): the Morse Code message to decode\n    \n    Returns:\n        str: The decoded English message\n    \n    Examples:\n        &gt;&gt;&gt; decode(\".... . .-.. .--. / ..- ...\")\n        'help us'\n    \"\"\"\n    english = []\n\n    # Now we cannot read by letter. We know that morse letters are\n    # separated by a space, so we split the morse string by spaces\n    morse_letters = message.split(\" \")\n\n    for letter in morse_letters:\n        english.append(_morse_to_letter[letter])\n\n    # Rejoin, but now we don't need to add any spaces\n    english_message = \"\".join(english)\n    \n    return english_message\n\nimport string\n\n_lower_cipher = string.ascii_lowercase[13:] + string.ascii_lowercase[:13]\n_upper_cipher = string.ascii_uppercase[13:] + string.ascii_uppercase[:13]\n\ndef encode(message):\n    \"\"\"\n    Encode a message from English to ROT13\n    \n    Args:\n        message (str): the English message to encode\n    \n    Returns:\n        str: The encoded message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\"Secretmessage\")\n        'Frpergzrffntr'\n    \"\"\"\n    output = []\n    for letter in message:\n        if letter in string.ascii_lowercase:\n            i = string.ascii_lowercase.find(letter)\n            output.append(_lower_cipher[i])\n        elif letter in string.ascii_uppercase:\n            i = string.ascii_uppercase.find(letter)\n            output.append(_upper_cipher[i])\n        else:  # Add this else statement\n            raise ValueError(f\"Cannot encode \\\"{message}\\\". Character \\\"{letter}\\\" not valid\")\n    \n    return \"\".join(output)\n\n\ndef decode(message):\n    \"\"\"\n    Encode a message from ROT13 to English\n    \n    Args:\n        message (str): the ROT13 message to encode\n    \n    Returns:\n        str: The decoded message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\"Frpergzrffntr\")\n        'Secretmessage'\n    \"\"\"\n    output = []\n    for letter in message:\n        if letter in _lower_cipher:\n            i = _lower_cipher.find(letter)\n            output.append(string.ascii_lowercase[i])  # ascii_uppercase → ascii_lowercase\n        elif letter in _upper_cipher:\n            i = _upper_cipher.find(letter)\n            output.append(string.ascii_uppercase[i])\n        else:  # Add this else statement\n            raise ValueError(f\"Cannot decode \\\"{message}\\\". Character \\\"{letter}\\\" not valid\")\n    \n    return \"\".join(output)\n\nimport pytest\n\nfrom morse import encode, decode\n\n@pytest.mark.parametrize(\"message\", [\n    \"sos\",\n    \"help us please\",\n    \"An Uppercase String\",\n])\ndef test_roundtrip(message):\n    assert decode(encode(message)) == message\n\nimport pytest\n\nfrom rot13 import encode, decode\n\n@pytest.mark.parametrize(\"message\", [\n    \"sos\",\n    \"helpusplease\",\n    \"AnUppercaseString\",\n])\ndef test_roundtrip(message):\n    assert decode(encode(message)) == message\nCOLUMNS=60 pytest -v morse.py rot13.py test_morse.py test_rot13.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 6 items                                          \u001b[0m\n\ntest_morse.py::test_roundtrip[sos] \u001b[32mPASSED\u001b[0m\u001b[32m            [ 16%]\u001b[0m\ntest_morse.py::test_roundtrip[help us please] \u001b[32mPASSED\u001b[0m\u001b[32m [ 33%]\u001b[0m\ntest_morse.py::test_roundtrip[An Uppercase String] \u001b[31mFAILED\u001b[0m\u001b[31m [ 50%]\u001b[0m\ntest_rot13.py::test_roundtrip[sos] \u001b[32mPASSED\u001b[0m\u001b[31m            [ 66%]\u001b[0m\ntest_rot13.py::test_roundtrip[helpusplease] \u001b[32mPASSED\u001b[0m\u001b[31m   [ 83%]\u001b[0m\ntest_rot13.py::test_roundtrip[AnUppercaseString] \u001b[32mPASSED\u001b[0m\u001b[31m [100%]\u001b[0m\n\n========================= FAILURES =========================\n\u001b[31m\u001b[1m___________ test_roundtrip[An Uppercase String] ____________\u001b[0m\n\nmessage = 'An Uppercase String'\n\n    \u001b[37m@pytest\u001b[39;49;00m.mark.parametrize(\u001b[33m\"\u001b[39;49;00m\u001b[33mmessage\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m, [\n        \u001b[33m\"\u001b[39;49;00m\u001b[33msos\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mhelp us please\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\n        \u001b[33m\"\u001b[39;49;00m\u001b[33mAn Uppercase String\u001b[39;49;00m\u001b[33m\"\u001b[39;49;00m,\n    ])\n    \u001b[94mdef\u001b[39;49;00m \u001b[92mtest_roundtrip\u001b[39;49;00m(message):\n&gt;       \u001b[94massert\u001b[39;49;00m decode(encode(message)) == message\n\u001b[1m\u001b[31mE       AssertionError: assert 'an uppercase string' == 'An Uppercase String'\u001b[0m\n\u001b[1m\u001b[31mE         - An Uppercase String\u001b[0m\n\u001b[1m\u001b[31mE         ? ^  ^         ^\u001b[0m\n\u001b[1m\u001b[31mE         + an uppercase string\u001b[0m\n\u001b[1m\u001b[31mE         ? ^  ^         ^\u001b[0m\n\n\u001b[1m\u001b[31mtest_morse.py\u001b[0m:12: AssertionError\n================= short test summary info ==================\nFAILED test_morse.py::test_roundtrip[An Uppercase String]\n\u001b[31m=============== \u001b[31m\u001b[1m1 failed\u001b[0m, \u001b[32m5 passed\u001b[0m\u001b[31m in 0.10s\u001b[0m\u001b[31m ================\u001b[0m\nThe Morse Code converter does not maintain the case of the string. All messages passed into it will be converted to lower case. This means that a message like “SOS” will, after round-tripping be “sos”. This means that in this case, the invariant of the round-trip is not that the messages are identical, but rather that they are “identical if you ignore case”.\nTo make our test do this, we can compare the round-tripped message against the lower case message with message.lower():\n\nimport pytest\n\nfrom morse import encode, decode\n\n@pytest.mark.parametrize(\"message\", [\n    \"sos\",\n    \"help us please\",\n    \"An Uppercase String\",\n])\ndef test_roundtrip(message):\n    assert decode(encode(message)) == message.lower()  # This line has changed\nCOLUMNS=60 pytest -v morse.py rot13.py test_morse.py test_rot13.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3\ncachedir: .pytest_cache\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: requests-mock-1.8.0\ncollected 6 items                                          \u001b[0m\n\ntest_morse.py::test_roundtrip[sos] \u001b[32mPASSED\u001b[0m\u001b[32m            [ 16%]\u001b[0m\ntest_morse.py::test_roundtrip[help us please] \u001b[32mPASSED\u001b[0m\u001b[32m [ 33%]\u001b[0m\ntest_morse.py::test_roundtrip[An Uppercase String] \u001b[32mPASSED\u001b[0m\u001b[32m [ 50%]\u001b[0m\ntest_rot13.py::test_roundtrip[sos] \u001b[32mPASSED\u001b[0m\u001b[32m            [ 66%]\u001b[0m\ntest_rot13.py::test_roundtrip[helpusplease] \u001b[32mPASSED\u001b[0m\u001b[32m   [ 83%]\u001b[0m\ntest_rot13.py::test_roundtrip[AnUppercaseString] \u001b[32mPASSED\u001b[0m\u001b[32m [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m6 passed\u001b[0m\u001b[32m in 0.02s\u001b[0m\u001b[32m =====================\u001b[0m"
  },
  {
    "objectID": "pages/answer_final_rot13_doc.html",
    "href": "pages/answer_final_rot13_doc.html",
    "title": "Best Practices in Software Engineering",
    "section": "",
    "text": "import string\n\n_lower_cipher = string.ascii_lowercase[13:] + string.ascii_lowercase[:13]\n_upper_cipher = string.ascii_uppercase[13:] + string.ascii_uppercase[:13]\n\ndef encode(message):\n    \"\"\"\n    Encode a message from English to ROT13\n    \n    Args:\n        message (str): the English message to encode\n    \n    Returns:\n        str: The encoded message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\"Secretmessage\")\n        'Frpergzrffntr'\n    \"\"\"\n    output = []\n    for letter in message:\n        if letter in string.ascii_lowercase:\n            i = string.ascii_lowercase.find(letter)\n            output.append(_lower_cipher[i])\n        elif letter in string.ascii_uppercase:\n            i = string.ascii_uppercase.find(letter)\n            output.append(_upper_cipher[i])\n    \n    return \"\".join(output)\n\n\ndef decode(message):\n    \"\"\"\n    Encode a message from ROT13 to English\n    \n    Args:\n        message (str): the ROT13 message to encode\n    \n    Returns:\n        str: The decoded message\n    \n    Examples:\n        &gt;&gt;&gt; encode(\"Frpergzrffntr\")\n        'Secretmessage'\n    \"\"\"\n    output = []\n    for letter in message:\n        if letter in _lower_cipher:\n            i = _lower_cipher.find(letter)\n            output.append(string.ascii_uppercase[i])\n        elif letter in _upper_cipher:\n            i = _upper_cipher.find(letter)\n            output.append(string.ascii_uppercase[i])\n    \n    return \"\".join(output)\nOverwriting rot13.py"
  },
  {
    "objectID": "pages/answer_test_raises.html",
    "href": "pages/answer_test_raises.html",
    "title": "Best Practices in Software Engineering",
    "section": "",
    "text": "\"\"\"\nThis module contains functions for manipulating and combining Python lists.\n\"\"\"\n\ndef add_arrays(x, y):\n    \"\"\"\n    This function adds together each element of the two passed lists.\n\n    Args:\n        x (list): The first list to add\n        y (list): The second list to add\n\n    Returns:\n        list: the pairwise sums of ``x`` and ``y``.\n    \n    Raises:\n        ValueError: If the length of the lists ``x`` and ``y`` are different.\n\n    Examples:\n        &gt;&gt;&gt; add_arrays([1, 4, 5], [4, 3, 5])\n        [5, 7, 10]\n    \"\"\"\n\n    if len(x) != len(y):\n        raise ValueError(\"Both arrays must have the same length.\")\n\n    z = []\n    for x_, y_ in zip(x, y):\n        z.append(x_ + y_)\n\n    return z\n\nimport pytest\n\nfrom arrays import add_arrays\n\ndef test_add_arrays_error():\n    a = [1, 2, 3]\n    b = [4, 5]\n    with pytest.raises(ValueError):\n        output = add_arrays(a, b)\nCOLUMNS=60 pytest test_arrays.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: attrib-0.1.3, requests-mock-1.8.0, cov-2.10.1, hypothesis-5.24.2\ncollected 1 item                                           \u001b[0m\n\ntest_arrays.py \u001b[32m.\u001b[0m\u001b[32m                                     [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m1 passed\u001b[0m\u001b[32m in 0.01s\u001b[0m\u001b[32m =====================\u001b[0m\n\nimport pytest\n\nfrom arrays import add_arrays\n\n@pytest.mark.parametrize(\"a, b\", [\n    ([1, 2, 3], [4, 5]),\n    ([1, 2], [4, 5, 6]),\n    ([], [4]),\n    ([4], []),\n])\ndef test_add_arrays_error(a, b):\n    a = [1, 2, 3]\n    b = [4, 5]\n    with pytest.raises(ValueError):\n        output = add_arrays(a, b)\nCOLUMNS=60 pytest test_arrays.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: attrib-0.1.3, requests-mock-1.8.0, cov-2.10.1, hypothesis-5.24.2\ncollected 4 items                                          \u001b[0m\n\ntest_arrays.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m                                  [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m4 passed\u001b[0m\u001b[32m in 0.01s\u001b[0m\u001b[32m =====================\u001b[0m"
  },
  {
    "objectID": "pages/001-workspace-setup.html",
    "href": "pages/001-workspace-setup.html",
    "title": "Workspace setup",
    "section": "",
    "text": "There are lots of different ways to run Python code and many tools to help you write it. You don’t require any special tools to create a Python script, a simple text editor like Notepad on Windows is sufficient. More advanced tools include things like Jupyter Notebooks and IDEs like PyCharm or Visual Studio Code.\nFor this workshop we will be keeping things as simple as possible in order to allow us to focus on the topics we’re learning without having to learn too many extra tools along the way.\nFor the purpose of this course we will be using a free tool called JupyterLab which provides you with a local editor in your web browser where you can write and run Python code. The easiest way to get access to JupyterLab is to install Anaconda which is a piece of software which includes Python along with lots of other tools. It is freely available for Windows, MacOS and Linux.\nAnaconda can be installed into your home area on your computer so if you are on a work laptop, for example, you will not need any special permissions. Once Anaconda is installed, start “Anaconda Navigator” and press the JupyterLab button on the main screen:\n\nThis will open JupyterLab in your default web browser and will look something like this:\n\nThe way that we will be setting up the space is to have a text editor on the left-hand side of the screen and a terminal on the right hand side. We’ll use the editor to write our code and the terminal to run it.\nIn the launcher tab, scoll down to the “Text File” entry and click that. It will turn the editor into a text editor. Then go to File → New and select “Terminal”. It will now have two tabs inside the interface, one labelled “untitled.txt” and the other labelled “Terminal 1”:\n\nThe contents of the Terminal tab will likely be a little different on your computer, compared to what is shown in thise images but that is ok.\nTo make our lives easier, let’s rearange things so that we can see the text editor at the same time as the terminal. Do this by pressing and holding down the left mouse button on the tab that says “Terminal 1” and slowly dragging it to the right-hand side of the window. You’ll see a blue outline like this:\n\nRelease the mouse button and you’ll end up with the two showing side-by-side:\n\n\nWorking directory\nSetting the correct working directory helps organize your project files and ensures that your code can find necessary resources and dependencies. We will revisit this concept later on, but for now be mindful that the space where you save your scripts has to be the same than the working directory in your Command Prompt/Terminal.\nIf you are using the Command Prompt (Windows) you can check your current directory with\n\n\nCommand Prompt\n\ncd\n\nIf you are using a Terminal (MacOS and Linux) you can check your current directory with\n\n\nTerminal\n\npwd\n\nWe recommend you to make a new directory, e.g. bestpractices, using the file browser on the left-hand side of JupyterLab (right-click→New Folder). Move into it in the file browser by double-clicking the name. All our Python files and outputs will go into this directory.\nWe’re now ready to get started!",
    "crumbs": [
      "Workspace setup"
    ]
  },
  {
    "objectID": "pages/answer_pytest_parametrise.html",
    "href": "pages/answer_pytest_parametrise.html",
    "title": "Best Practices in Software Engineering",
    "section": "",
    "text": "\"\"\"\nThis module contains functions for manipulating and combining Python lists.\n\"\"\"\n\ndef add_arrays(x, y):\n    \"\"\"\n    This function adds together each element of the two passed lists.\n\n    Args:\n        x (list): The first list to add\n        y (list): The second list to add\n\n    Returns:\n        list: the pairwise sums of ``x`` and ``y``.\n\n    Examples:\n        &gt;&gt;&gt; add_arrays([1, 4, 5], [4, 3, 5])\n        [5, 7, 10]\n    \"\"\"\n    z = []\n    for x_, y_ in zip(x, y):\n        z.append(x_ + y_)\n\n    return z\n\nimport pytest\n\nfrom arrays import add_arrays\n\n@pytest.mark.parametrize(\"a, b, expect\", [\n    ([1, 2, 3], [4, 5, 6], [5, 7, 9]),\n    ([-1, -5, -3], [-4, -3, 0], [-5, -8, -3]),\n    ([41, 0, 3], [4, 76, 32], [45, 76, 35]),\n    ([], [], []),\n])\ndef test_add_arrays(a, b, expect):\n    output = add_arrays(a, b)\n    \n    assert output == expect\nCOLUMNS=60 pytest test_arrays.py\n\u001b[1m=================== test session starts ====================\u001b[0m\nplatform linux -- Python 3.8.5, pytest-6.0.1, py-1.9.0, pluggy-0.13.1\nrootdir: /home/matt/projects/courses/software_engineering_best_practices\nplugins: attrib-0.1.3, requests-mock-1.8.0, cov-2.10.1, hypothesis-5.24.2\ncollected 4 items                                          \u001b[0m\n\ntest_arrays.py \u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m.\u001b[0m\u001b[32m                                  [100%]\u001b[0m\n\n\u001b[32m==================== \u001b[32m\u001b[1m4 passed\u001b[0m\u001b[32m in 0.01s\u001b[0m\u001b[32m =====================\u001b[0m"
  }
]